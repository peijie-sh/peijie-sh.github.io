<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lingpj&#39;s blog</title>
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://peijie-sh.github.io/"/>
  <updated>2018-09-10T08:10:48.866Z</updated>
  <id>https://peijie-sh.github.io/</id>
  
  <author>
    <name>Joepis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK默认使用的垃圾回收器</title>
    <link href="https://peijie-sh.github.io/2018/09/09/JDK%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://peijie-sh.github.io/2018/09/09/JDK默认使用的垃圾回收器/</id>
    <published>2018-09-09T00:45:32.000Z</published>
    <updated>2018-09-10T08:10:48.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h1><blockquote>
<p>java -XX:+PrintCommandLineFlags -version</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c281fa5a86eca?w=959&amp;h=128&amp;f=png&amp;s=15930" alt="这里写图片描述"><br><a id="more"></a><br>引用《深入理解Java虚拟机：JVM高级特性与最佳实践》的介绍：<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c281fa572a1b9?w=994&amp;h=390&amp;f=png&amp;s=173349" alt="这里写图片描述"></p>
<p>所以，jdk8环境下，默认使用 Parallel Scavenge（新生代）+ Serial Old（老年代）</p>
<ul>
<li>-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型</li>
<li>-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看方法&quot;&gt;&lt;a href=&quot;#查看方法&quot; class=&quot;headerlink&quot; title=&quot;查看方法&quot;&gt;&lt;/a&gt;查看方法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;java -XX:+PrintCommandLineFlags -version&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c281fa5a86eca?w=959&amp;amp;h=128&amp;amp;f=png&amp;amp;s=15930&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://peijie-sh.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="垃圾回收器" scheme="https://peijie-sh.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（七）：垃圾回收器</title>
    <link href="https://peijie-sh.github.io/2018/06/29/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://peijie-sh.github.io/2018/06/29/理解JVM（七）：垃圾回收器/</id>
    <published>2018-06-29T03:35:12.000Z</published>
    <updated>2018-09-10T02:55:15.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h2><p>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
<h2 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h2><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<a id="more"></a>
<h1 id="HotSpot虚拟机的垃圾回收器"><a href="#HotSpot虚拟机的垃圾回收器" class="headerlink" title="HotSpot虚拟机的垃圾回收器"></a>HotSpot虚拟机的垃圾回收器</h1><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><ul>
<li>最基本的单线程垃圾收集器。使用一个CPU或一条收集线程去执行垃圾收集工作。</li>
<li>工作时会<code>Stop The World</code>，暂停所有用户线程，造成卡顿。适合运行在Client模式下的虚拟机。</li>
<li>用作新生代收集器，复制算法。</li>
</ul>
<h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><ul>
<li>Serial收集器的多线程版本，和Serial的唯一区别就是使用了多条线程去垃圾收集。</li>
<li>除了Serial，只有它可以和CMS搭配使用的收集器。</li>
<li>用作新生代收集器，复制算法。</li>
</ul>
<h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><ul>
<li>用作新生代收集器，复制算法。</li>
<li>关注高吞吐量，可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
<li>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</li>
</ul>
<h2 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h2><ul>
<li>Serial收集器的老年代版本，单线程，标记-整理 算法。</li>
<li>一般用于Client模式的虚拟机。</li>
<li>当虚拟机是Server模式时，有2个用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 ，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><ul>
<li>Parallel Scavenge收集器的老年代版本，使用多线程和 标记-整理 算法。在JDK 1.6中开始提供。</li>
<li>在注重吞吐量的场合，配合Parallel Scavenge收集器使用。</li>
</ul>
<h2 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h2><ul>
<li>一种以获取最短回收停顿时间为目标的收集器。适合需要与用户交互的程序，良好的响应速度能提升用户体验。</li>
<li>基于 标记—清除 算法。适合作为老年代收集器。</li>
<li>收集过程分4步：<ul>
<li>初始标记（CMS initial mark）：只是标记一下GC Roots能直接关联到的对象，速度很快，会<code>Stop The World</code>。</li>
<li>并发标记（CMS concurrent mark）：进行GC Roots Tracing（可达性分析）的过程。</li>
<li>重新标记（CMS remark）：会<code>Stop The World</code>。为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记阶段稍长些，但远比并发标记的时间短。</li>
<li>并发清除（CMS concurrent sweep）：回收内存。</li>
</ul>
</li>
<li>耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以是并发执行的。</li>
<li>缺点：<ul>
<li>并发阶段，虽然不会导致用户线程暂停，但会占用一部分线程（CPU资源），导致应用变慢，吞吐量降低。默认启动收集线程数是（CPU数量+3）/4。即当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大。</li>
<li>无法清除浮动垃圾。并发清除阶段，用户线程还在运行，还会产生新垃圾。这些垃圾不会在此次GC中被标记，只能等到下次GC被回收。</li>
<li>标记-清除 算法会产生大量不连续内存，导致分配大对象时内存不够，提前触发Full GC。</li>
</ul>
</li>
</ul>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><ul>
<li>在JDK1.7提供的先进垃圾收集器。</li>
<li>既适合新生代，也适合老年代。</li>
<li>空间整合：使用 标记-整理 算法，不产生碎片空间。</li>
<li>整个Java堆被分为多个大小相同的的块（region）。新生代和老年代不再是物理隔离的，而是一部分region块组成的集合。</li>
<li>可预测的停顿时间：估算每个region内的垃圾可回收的空间以及回收需要的时间（经验值），记录在一个优先列表中。收集时，优先回收价值最大的region，而不是在整个堆进行全区域回收。这样提高了回收效率，得名：Garbage-First。</li>
<li><p>回收步骤：</p>
<ul>
<li>初始标记（Initial Marking）：只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking）：进行可达性分析，找出存活对象，耗时长，但可与用户线程并发。</li>
<li>最终标记（Final Marking）：修正并发标记阶段用户线程运行导致的变动记录。会<code>Stop The World</code>，但可以并行执行，时间不会很长。</li>
<li>筛选回收（Live Data Counting and Evacuation）：根据每个region的回收价值和回收成本排序，根据用户配置的GC停顿时间开始回收。</li>
</ul>
</li>
<li><p>当内存很少的时候（存活对象占用大量空间），没有足够空间来复制对象，会导致回收失败。这时会保留被移动过的对象和没移动的对象，只调整引用。失败发生后，收集器认为存活对象被移动了，有足够空间让应用程序使用，于是用户线程继续工作，等待下一次触发GC。如果内存不够，就会触发Full GC。</p>
</li>
</ul>
<p><a href="https://docs.oracle.com/javase/10/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F" target="_blank" rel="external">参考G1的详细介绍</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h1&gt;&lt;h2 id=&quot;并行（Parallel）&quot;&gt;&lt;a href=&quot;#并行（Parallel）&quot; class=&quot;headerlink&quot; title=&quot;并行（Parallel）&quot;&gt;&lt;/a&gt;并行（Parallel）&lt;/h2&gt;&lt;p&gt;指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。&lt;/p&gt;
&lt;h2 id=&quot;并发（Concurrent）&quot;&gt;&lt;a href=&quot;#并发（Concurrent）&quot; class=&quot;headerlink&quot; title=&quot;并发（Concurrent）&quot;&gt;&lt;/a&gt;并发（Concurrent）&lt;/h2&gt;&lt;p&gt;指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。&lt;/p&gt;
&lt;h2 id=&quot;吞吐量&quot;&gt;&lt;a href=&quot;#吞吐量&quot; class=&quot;headerlink&quot; title=&quot;吞吐量&quot;&gt;&lt;/a&gt;吞吐量&lt;/h2&gt;&lt;p&gt;CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="垃圾回收器" scheme="https://peijie-sh.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（六）：线程安全和锁优化</title>
    <link href="https://peijie-sh.github.io/2018/06/27/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://peijie-sh.github.io/2018/06/27/理解JVM（六）：线程安全和锁优化/</id>
    <published>2018-06-27T06:17:42.000Z</published>
    <updated>2018-08-20T12:21:16.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>互斥是因，同步是果；互斥是方法，同步是目的。</p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ul>
<li><code>synchronized</code>关键字是基本的互斥同步手段。它在编译后会在同步代码块前后加入2条字节码指令：<code>monitorenter</code>和<code>monitorexit</code>。</li>
<li>这两个字节码都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。如果Java程序中的<code>synchronized</code>指定了对象参数，那就是这个对象的<code>reference</code>；如果没有指定，就根据<code>synchronized</code>修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</li>
<li>执行<code>monitorenter</code>指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或当前线程已经拥有了那个对象的锁，把锁的计数器加1；在执行<code>monitorexit</code>指令时会将锁计数器减1。当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</li>
<li><code>synchronized</code>同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li>
<li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li>
<li>Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，所以synchronized是Java语言中一个重量级的操作。不过虚拟机会有一些优化措施，比如自旋等待。<a id="more"></a>
<h3 id="ReentrantLock重入锁"><a href="#ReentrantLock重入锁" class="headerlink" title="ReentrantLock重入锁"></a>ReentrantLock重入锁</h3>重入锁位于<code>java.util.concurrent</code>包。基本用法和<code>synchronized</code>相似，只是代码写法有区别：<code>synchronized</code>是原生语法层面的实现。<code>ReentrantLock</code>是API层面，使用<code>lock()</code>和<code>unlock()</code>方法配合<code>try/finally</code>语句块来实现。</li>
</ul>
<p>重入锁有3个高级特性：</p>
<ul>
<li>等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>可实现公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li>
<li>锁可以绑定多个条件：一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象，而在<code>synchronized</code>中，锁对象的<code>wait()</code>和<code>notify()</code>或<code>notifyAll()</code>方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而<code>ReentrantLock</code>则无须这样做，只需要多次调用<code>newCondition()</code>方法即可。</li>
</ul>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul>
<li>JDK1.6之前，在多线程环境下，<code>synchronized</code>的吞吐量随着处理器数量增加而下降得非常严重。</li>
<li>JDK1.6之后，虚拟机做了优化，2种方式性能差不多。推荐优先使用<code>synchronized</code>方式。</li>
</ul>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。</p>
<p>按处理问题的方式来说：</p>
<ul>
<li>互斥同步是悲观并发策略：无论是否产生共享数据争用，都会做同步措施（加锁，用户态内核态转换等）。</li>
<li>非阻塞同步是一种乐观并发策略：它基于冲突检测。通俗的说，就是先执行代码，若没有发生共享数据争用，就成功执行；若发生共享数据争用，就采取补偿措施（比如不断重试，直到成功），这种策略不会导致线程阻塞。</li>
</ul>
<p>CAS操作：<br>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，这个处理过程是个原子操作。</p>
<p>ABA问题：<br>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>如果一个方法本来就不涉及共享数据，那它就无须任何同步措施去保证正确性。</p>
<ul>
<li>可重入代码：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</li>
<li>线程本地存储：一段代码中所需要的数据必须与其他代码共享，并且可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<ul>
<li>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread） 这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li>
</ul>
</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="适应性自旋（Adaptive-Spinning）"><a href="#适应性自旋（Adaptive-Spinning）" class="headerlink" title="适应性自旋（Adaptive Spinning）"></a>适应性自旋（Adaptive Spinning）</h2><p>线程阻塞的时候，让等待的线程不放弃cpu执行时间，而是执行一个自旋(一般是空循环)，这叫做自旋锁。</p>
<p>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能上的浪费。</p>
<p>因此，自旋等待的时间必须要有一定的限度。如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数<code>-XX：PreBlockSpin</code>来更改。</p>
<p>JDK1.6引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。比如前一次自旋了3次就获得了一个锁，那么下一次虚拟机会允许他自旋更多次来获得这个锁。如果一个锁很少能通过自旋成功获得，那么之后再遇到这个情况就会省略自旋过程了。</p>
<h2 id="锁消除（Lock-Elimination）"><a href="#锁消除（Lock-Elimination）" class="headerlink" title="锁消除（Lock Elimination）"></a>锁消除（Lock Elimination）</h2><p>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。一般根据逃逸分析的数据支持来作为判定依据。</p>
<h2 id="锁粗化（Lock-Coarsening）"><a href="#锁粗化（Lock-Coarsening）" class="headerlink" title="锁粗化（Lock Coarsening）"></a>锁粗化（Lock Coarsening）</h2><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>但如果一系列操作频繁对同一个对象加锁解锁，或者加锁操作再循环体内，会耗费性能，这时虚拟机会扩大加锁范围。</p>
<h2 id="轻量级锁（Lightweight-Locking）"><a href="#轻量级锁（Lightweight-Locking）" class="headerlink" title="轻量级锁（Lightweight Locking）"></a>轻量级锁（Lightweight Locking）</h2><p>轻量级锁是JDK 1.6之中加入的新型锁机制。它的作用是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，这部分称<code>为Mark Word</code>。还有一部分存储指向方法区对象类型数据的指针。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock  Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态。如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁过程也是通过CAS操作来进行的。如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>没有锁竞争时，轻量级锁用CAS操作替代互斥量的开销，性能较优。有锁竞争时，除了互斥量开销，还有CAS操作开销，所以性能较差。但是，一般情况下，在整个同步周期内都是不存在竞争的”，这是一个经验数据。</p>
<h2 id="偏向锁（Biased-Locking）"><a href="#偏向锁（Biased-Locking）" class="headerlink" title="偏向锁（Biased Locking）"></a>偏向锁（Biased Locking）</h2><p>偏向锁也是JDK1.6中引入的锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式结束。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但并不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX：-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程安全的实现方法&quot;&gt;&lt;a href=&quot;#线程安全的实现方法&quot; class=&quot;headerlink&quot; title=&quot;线程安全的实现方法&quot;&gt;&lt;/a&gt;线程安全的实现方法&lt;/h1&gt;&lt;h2 id=&quot;互斥同步&quot;&gt;&lt;a href=&quot;#互斥同步&quot; class=&quot;headerlink&quot; title=&quot;互斥同步&quot;&gt;&lt;/a&gt;互斥同步&lt;/h2&gt;&lt;p&gt;互斥是因，同步是果；互斥是方法，同步是目的。&lt;/p&gt;
&lt;h3 id=&quot;synchronized关键字&quot;&gt;&lt;a href=&quot;#synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字&quot;&gt;&lt;/a&gt;synchronized关键字&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt;关键字是基本的互斥同步手段。它在编译后会在同步代码块前后加入2条字节码指令：&lt;code&gt;monitorenter&lt;/code&gt;和&lt;code&gt;monitorexit&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这两个字节码都需要一个&lt;code&gt;reference&lt;/code&gt;类型的参数来指明要锁定和解锁的对象。如果Java程序中的&lt;code&gt;synchronized&lt;/code&gt;指定了对象参数，那就是这个对象的&lt;code&gt;reference&lt;/code&gt;；如果没有指定，就根据&lt;code&gt;synchronized&lt;/code&gt;修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;monitorenter&lt;/code&gt;指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或当前线程已经拥有了那个对象的锁，把锁的计数器加1；在执行&lt;code&gt;monitorexit&lt;/code&gt;指令时会将锁计数器减1。当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt;同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。&lt;/li&gt;
&lt;li&gt;同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。&lt;/li&gt;
&lt;li&gt;Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，所以synchronized是Java语言中一个重量级的操作。不过虚拟机会有一些优化措施，比如自旋等待。
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
      <category term="锁" scheme="https://peijie-sh.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（五）：Java内存模型与线程</title>
    <link href="https://peijie-sh.github.io/2018/06/26/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://peijie-sh.github.io/2018/06/26/理解JVM（五）：Java内存模型与线程/</id>
    <published>2018-06-26T07:21:57.000Z</published>
    <updated>2018-08-20T12:21:16.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>JMM(Java Memory Model)是JVM定义的内存模型，用来屏蔽各种硬件和操作系统的内存访问差异。</p>
<ul>
<li>主内存：所有的变量都存储在主内存（Main Memory，类比物理内存）中。</li>
<li>工作内存：每条线程有自己的工作内存（Working Memory，类比处理器高速缓存），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/26/1643b32111adede2?w=1028&amp;h=411&amp;f=png&amp;s=131712" alt=""></p>
<a id="more"></a>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>其中read和load，store和write必须成对使用，顺序但补一定连续的执行。通俗的说，就是执行了read，后面一定会执行load，但不一定read之后立马load；store和write也一样。lock和unlock也是成对出现，一个变量在同一时间点只能有一个线程对其进行lock。</p>
<ol>
<li><p>对于普通变量的操作：<br>创建变量，是在主内存中初始化。<br>线程用到的变量，会先从主内存中拷贝(<code>read</code>)出来，加载(<code>load</code>)到工作内存，然后引用(<code>use</code>)变量并运算赋值(<code>assign</code>)。然后存储(<code>store</code>)到工作内存，然后更新(<code>write</code>)掉原来的变量。</p>
<p> 普通变量的值在线程间传递均需要通过主内存来完成。例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p>
</li>
<li><p>对于<code>volatile</code>修饰的变量:过程和普通变量一样。但保证变量对所有线程的可见性，并且会禁止指令重排序的优化。</p>
<p> volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
</li>
</ol>
<h2 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h2><p>它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</p>
<h2 id="实现线程的3种方式："><a href="#实现线程的3种方式：" class="headerlink" title="实现线程的3种方式："></a>实现线程的3种方式：</h2><ul>
<li>使用内核线程实现<ul>
<li>内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</li>
<li>程序一般不直接使用内核线程，而是轻量级进程（通俗意义上的线程）。此2者<code>1:1</code>对应关系。创建，调用同步等都由系统执行，代价较高（需要在内核态和用户态之间来回切换），每个轻量级进程会消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持的轻量级进程时有限的。</li>
</ul>
</li>
<li>使用用户线程实现<ul>
<li>广义来说，一个线程只要不是内核线程，就可以认为是用户线程。因此，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。</li>
<li>狭义的说，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间<code>1:N</code>的关系称为一对多的线程模型。</li>
<li>使用用户线程的优势在于不需要系统内核支援，劣势也是没有系统内核的支援。所有的线程操作都需要用户程序自己处理，实现会很复杂，所以现在很少使用了。</li>
</ul>
</li>
<li>使用用户线程加轻量级进程混合实现<ul>
<li>既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为<code>N:M</code>的关系，这种就是多对多的线程模型。</li>
</ul>
</li>
</ul>
<p>Java线程实现：JDK1.2之前是用户线程，1.2和之后的版本，使用操作系统原生线程模型（内核线程）。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：</p>
<ul>
<li>协同式线程调度（Cooperative Threads-Scheduling）：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。<ul>
<li>好处：实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</li>
<li>坏处：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</li>
</ul>
</li>
<li>抢占式线程调度（Preemptive Threads-Scheduling）：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，<code>Thread.yield()</code>可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度 。</li>
</ul>
<p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的线程少分配一点——通过设置线程优先级的方式(两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行)，不过这方法不是很可靠，因为系统线程优先级和Java的10种线程优先级不一定一一对应。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>在任意时间点，一个线程只有一种状态</p>
<ul>
<li>新建(New)：创建后尚未启动</li>
<li>运行(Runable)：正在执行或正在等待CPU为它分配执行时间</li>
<li>等待(Waiting)：<ul>
<li>无限等待(Waiting)：线程不会被分配CPU执行时间，等待被其他线程显式地唤醒。</li>
<li>期限等待(Timed Waiting)：线程不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间后它们会由系统自动唤醒。</li>
</ul>
</li>
<li>阻塞(Blocked)：被阻塞<ul>
<li>阻塞和等待的区别：<code>阻塞状态</code>在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而<code>等待状态</code>则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
</ul>
</li>
<li>结束(Terminated)：已终止</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/26/1643b31ce9d19418?w=862&amp;h=594&amp;f=png&amp;s=157536" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;p&gt;JMM(Java Memory Model)是JVM定义的内存模型，用来屏蔽各种硬件和操作系统的内存访问差异。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主内存：所有的变量都存储在主内存（Main Memory，类比物理内存）中。&lt;/li&gt;
&lt;li&gt;工作内存：每条线程有自己的工作内存（Working Memory，类比处理器高速缓存），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/26/1643b32111adede2?w=1028&amp;amp;h=411&amp;amp;f=png&amp;amp;s=131712&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
      <category term="JMM" scheme="https://peijie-sh.github.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Spring的事件机制</title>
    <link href="https://peijie-sh.github.io/2018/06/15/Spring%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://peijie-sh.github.io/2018/06/15/Spring的事件机制/</id>
    <published>2018-06-15T09:21:43.000Z</published>
    <updated>2018-08-20T12:21:16.245Z</updated>
    
    <content type="html"><![CDATA[<p>当把一个事件发布到Spring提供的<code>ApplicationContext</code>中，被监听器侦测到，就会执行对应的处理方法。</p>
<h1 id="事件本身"><a href="#事件本身" class="headerlink" title="事件本身"></a>事件本身</h1><p>事件是一个自定义的类，需要继承Spring提供的<code>ApplicationEvent</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String msg;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(source);</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>基本方法是实现<code>ApplicationListener</code>接口，自定义一个监听器，实现<code>onApplicationEvent()</code>方法，然后添加到<code>ApplicationContext</code>。<br>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;  </div><div class="line"></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;  </div><div class="line">        System.out.print(<span class="string">"监听到MyEvent事件"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">...</div><div class="line"><span class="comment">// SpringBoot的启动类中添加监听器</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class);</div><div class="line">		application.addListeners(<span class="keyword">new</span> MyListener());</div><div class="line">		application.run(args);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用注解<code>@EventListener</code>（推荐）：原理就是通过扫描这个注解，创建监听器并添加到<code>ApplicationContext</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"------------处理事件：&#123;&#125;"</span>, event.getMsg());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</div><div class="line">            log.info(<span class="string">"事件1(5s)处理完成"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h1><p>可以通过上下文对象的发布方法<code>ConfigurableApplicationContext::publishEvent()</code>来发布。<br>也可以实现<code>ApplicationEventPublisherAware</code>接口来发布（推荐）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ApplicationEventPublisher publisher;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEventWork</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"------------publish event:"</span> + msg);</div><div class="line">        MyEvent event = <span class="keyword">new</span> MyEvent(<span class="keyword">this</span>, msg);</div><div class="line">        publisher.publishEvent(event);</div><div class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventServiceTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> EventService service;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        String msg=<span class="string">"Java Code"</span>;</div><div class="line">        service.doEventWork(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402c8b84e8e00b?w=1371&amp;h=78&amp;f=png&amp;s=15710" alt=""></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果2个事件之间是继承关系，会先监听到子类事件，处理完再监听父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyEvent2 extends MyEvent</span></div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"------------处理事件：&#123;&#125;"</span>, event.getMsg());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</div><div class="line">            log.info(<span class="string">"事件1(5s)处理完成"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent2</span><span class="params">(MyEvent2 event)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"------------处理事件2：&#123;&#125;"</span>, event.getMsg());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000L</span>);</div><div class="line">            log.info(<span class="string">"事件2(10s)处理完成"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我publish一个子类事件MyEvent2时，日志如下：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402ca4e7d6a8c4?w=1421&amp;h=136&amp;f=png&amp;s=33952" alt=""></h2><p>注意：默认是同步事件，如要使用异步，需要在Application上开启异步，并在监听器上使用<code>@Async</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当把一个事件发布到Spring提供的&lt;code&gt;ApplicationContext&lt;/code&gt;中，被监听器侦测到，就会执行对应的处理方法。&lt;/p&gt;
&lt;h1 id=&quot;事件本身&quot;&gt;&lt;a href=&quot;#事件本身&quot; class=&quot;headerlink&quot; title=&quot;事件本身&quot;&gt;&lt;/a&gt;事件本身&lt;/h1&gt;&lt;p&gt;事件是一个自定义的类，需要继承Spring提供的&lt;code&gt;ApplicationEvent&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Data&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyEvent&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ApplicationEvent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String msg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object source, String msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(source);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.msg = msg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://peijie-sh.github.io/categories/Spring/"/>
    
    
      <category term="SpringBoot" scheme="https://peijie-sh.github.io/tags/SpringBoot/"/>
    
      <category term="Event" scheme="https://peijie-sh.github.io/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>TCP的3次握手和4次挥手过程</title>
    <link href="https://peijie-sh.github.io/2018/04/09/TCP%E7%9A%843%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>https://peijie-sh.github.io/2018/04/09/TCP的3次握手和4次挥手过程/</id>
    <published>2018-04-09T02:15:35.000Z</published>
    <updated>2018-09-10T08:11:23.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立连接（3次握手）"><a href="#建立连接（3次握手）" class="headerlink" title="建立连接（3次握手）"></a>建立连接（3次握手）</h1><p><img src="https://upload-images.jianshu.io/upload_images/4059338-8dec28773da8005b.png" alt="TCP3次握手.png"></p>
<a id="more"></a>
<ul>
<li>SYN是标志位，设置SYN=1，表示请求建立连接</li>
<li>服务端会同时和多个客户端建立连接，所以在报文交互时，需要带上序号seq，在响应是seq+1，以此来检测报文合法性</li>
</ul>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ul>
<li>客户端：我想建立一个连接。状态：CLOSED -&gt; SYN SENT</li>
<li>服务端：可以，我同意建立连接。状态：LISTEN -&gt; SYN RCVD</li>
<li>客户端：好的，我收到你的确认，我准备好接收数据了。状态：SYN SENT -&gt; ESTABLISHED</li>
<li>服务端听到客户端准备好了，也进入准备状态。状态：SYN RCVD -&gt; ESTABLISHED</li>
</ul>
<p>至此，TCP连接就建立完毕，开始互相发送数据了。</p>
<h1 id="断开连接（4次挥手）"><a href="#断开连接（4次挥手）" class="headerlink" title="断开连接（4次挥手）"></a>断开连接（4次挥手）</h1><p><img src="https://upload-images.jianshu.io/upload_images/4059338-140f04e2f323b7b5.png" alt="TCP4次挥手.png"></p>
<ul>
<li>FIN是标志位，设置FIN=1，表示请求断开连接</li>
</ul>
<h3 id="断开连接过程"><a href="#断开连接过程" class="headerlink" title="断开连接过程"></a>断开连接过程</h3><ul>
<li>客户端：我数据发完了，我要断开连接了。状态：ESTABLISHED -&gt; FIN WAIT 1</li>
<li>服务端：好，我知道你要断开连接了。状态：ESTABLISHED -&gt; CLOSE WAIT</li>
</ul>
<p>此时，客户端确认服务端已经知道要断开了。但是，服务端可能还有数据没发送完，所以客户端还能接收数据但不会发送数据。状态：FIN WAIT 1 -&gt; FIN WAIT 2</p>
<p>过了一会，服务端数据发完了。</p>
<ul>
<li>服务端：我准备好了，断开连接吧。状态：CLOSE WAIT -&gt; LAST ACK</li>
<li>客户端：好，那我断开连接了，再见。状态：FIN WAIT 2 -&gt; TIME WAIT</li>
<li>服务端：客户端已经断开了，我也断开吧。状态：LAST ACK -&gt; CLOSED</li>
<li>客户端等待2个MSL时间以后断开连接，状态：TIME WAIT -&gt; CLOSED</li>
</ul>
<h1 id="TCP握手挥手的状态"><a href="#TCP握手挥手的状态" class="headerlink" title="TCP握手挥手的状态"></a>TCP握手挥手的状态</h1><table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLOSED</td>
<td style="text-align:center">关闭状态，没有连接活动或正在进行</td>
</tr>
<tr>
<td style="text-align:center">LISTEN</td>
<td style="text-align:center">监听状态，服务器正在等待连接进入</td>
</tr>
<tr>
<td style="text-align:center">SYN SENT</td>
<td style="text-align:center">已经发出连接请求，等待确认</td>
</tr>
<tr>
<td style="text-align:center">SYN RCVD</td>
<td style="text-align:center">收到一个连接请求，尚未确认</td>
</tr>
<tr>
<td style="text-align:center">ESTABLISHED</td>
<td style="text-align:center">连接建立，正常数据传输状态</td>
</tr>
<tr>
<td style="text-align:center">FIN WAIT 1</td>
<td style="text-align:center">（主动关闭）已经发送关闭请求，等待确认</td>
</tr>
<tr>
<td style="text-align:center">FIN WAIT 2</td>
<td style="text-align:center">（主动关闭）收到对方关闭确认，等待对方关闭请求</td>
</tr>
<tr>
<td style="text-align:center">TIME WAIT</td>
<td style="text-align:center">完成双向关闭，等待所有分组死掉</td>
</tr>
<tr>
<td style="text-align:center">CLOSE WAIT</td>
<td style="text-align:center">（被动关闭）收到对方关闭请求，已经确认</td>
</tr>
<tr>
<td style="text-align:center">LAST ACK</td>
<td style="text-align:center">（被动关闭）等待最后一个关闭确认，并等待所有分组死掉</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">双方同时尝试关闭，等待对方确认</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;建立连接（3次握手）&quot;&gt;&lt;a href=&quot;#建立连接（3次握手）&quot; class=&quot;headerlink&quot; title=&quot;建立连接（3次握手）&quot;&gt;&lt;/a&gt;建立连接（3次握手）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4059338-8dec28773da8005b.png&quot; alt=&quot;TCP3次握手.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://peijie-sh.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="TCP/IP" scheme="https://peijie-sh.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（四）：JVM类加载机制</title>
    <link href="https://peijie-sh.github.io/2018/02/06/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://peijie-sh.github.io/2018/02/06/理解JVM（四）：JVM类加载机制/</id>
    <published>2018-02-06T05:27:51.000Z</published>
    <updated>2018-08-20T12:21:16.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h1><p>我们写的Java代码，经过编译器编译之后，就成为了<code>.class</code>文件，从本地机器码变成了字节码。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。Class文件中只有2种数据结构：无符号数和表。</p>
<a id="more"></a>
<p>每个Class文件的头4个字节称为魔数（Magic Number），值为<code>0xCAFEBABE</code>。紧接着4个字节是Class文件的版本号。再往后，就是类的具体信息了，比如常量池、类索引、父类索引、接口索引、字段、方法等信息了。</p>
<p>所谓类的加载，就是把Class文件读到内存中。</p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/164212e84e3ed0d4?w=1175&amp;h=466&amp;f=png&amp;s=157532" alt=""><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机做3件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成4个阶段的检验动作</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。比如是否以魔数<code>0xCAFEBABE</code>开头，主、次版本号是否能被当前虚拟机处理，常量类型，指向常量的索引是否符合要求等。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
<li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。比如继承关系。</li>
<li>字节码验证：对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行。它发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的。它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。</p>
<blockquote>
<p>假设一个类变量的定义为：public static int value = 123;</p>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java<br>方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方<br>法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
</blockquote>
<p>当然也有特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。</p>
<blockquote>
<p>假设上面类变量value的定义变为：public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可<br>以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的<br>内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各<br>不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义<br>在Java虚拟机规范的Class文件格式中。</li>
<li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是<br>一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引<br>用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目<br>标必定已经在内存中存在。</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这一步开始执行类中定义的Java程序代码（或者说是字节码）。虚拟机会保证一个类的初始化方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的初始化方法，其他线程都需要阻塞等待，直到活动线程执行完毕。</p>
<h3 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h3><ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p>只有当主动使用一个类的时候才会触发这个类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射，比如<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>从Java开发人员的角度来看，类加载器可以划分为以下3种：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）：负责加载存放在JAVA_HOME\lib目录中的，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器（Extension ClassLoader）：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JAVA_HOME\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入<br>自己定义的类加载器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/21/1642187992e17854?w=720&amp;h=815&amp;f=png&amp;s=182504" alt=""></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以<code>继承</code>的关系来实现，而是都使用<code>组合</code>关系来复用父加载器的代码。它不是强制性的约束模型，而是Java设计者推荐的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>ClassLoader源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        <span class="comment">// 首先判断该类型是否已经被加载</span></div><div class="line">        Class c = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                     <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></div><div class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></div><div class="line">                    c = findBootstrapClass0(name);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></div><div class="line">                c = findClass(name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过分析源码，我们知道，双亲委派模型可以保证每个类都只会被加载一次（类似缓存机制）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《深入理解Java虚拟机 第二版》</li>
<li><a href="http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html" target="_blank" rel="external">纯洁的微笑</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Class文件&quot;&gt;&lt;a href=&quot;#Class文件&quot; class=&quot;headerlink&quot; title=&quot;Class文件&quot;&gt;&lt;/a&gt;Class文件&lt;/h1&gt;&lt;p&gt;我们写的Java代码，经过编译器编译之后，就成为了&lt;code&gt;.class&lt;/code&gt;文件，从本地机器码变成了字节码。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。Class文件中只有2种数据结构：无符号数和表。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（三）：JVM命令工具</title>
    <link href="https://peijie-sh.github.io/2018/01/28/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJVM%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <id>https://peijie-sh.github.io/2018/01/28/理解JVM（三）：JVM命令工具/</id>
    <published>2018-01-28T02:25:42.000Z</published>
    <updated>2018-08-20T12:21:16.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jps（JVM-Process-Status-Tool）"><a href="#jps（JVM-Process-Status-Tool）" class="headerlink" title="jps（JVM Process Status Tool）"></a>jps（JVM Process Status Tool）</h1><p>虚拟机进程状况工具，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（MainClass,main（）函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。</p>
<ul>
<li>命令格式：<code>jps[options][hostid]</code></li>
<li><p>参数：</p>
<ul>
<li><code>-q</code>：只输出LVMID，省略主类名称</li>
<li><code>-m</code>：输出虚拟机进程启动时传给主类main()函数的参数</li>
<li><code>-l</code>：输出主类全名，如果进程执行的时jar包则输出jar路径</li>
<li><code>-v</code>：输出虚拟机进程启动时的jvm参数<a id="more"></a>
<h1 id="jstat（JVM-Statistics-Monitoring-Tool）"><a href="#jstat（JVM-Statistics-Monitoring-Tool）" class="headerlink" title="jstat（JVM Statistics Monitoring Tool）"></a>jstat（JVM Statistics Monitoring Tool）</h1>虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</li>
</ul>
</li>
<li><p>命令格式：<code>jstat[option vmid[interval[s|ms][count]]]</code></p>
</li>
<li>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是：<code>[protocol：][//]lvmid[@hostname[：port]/servername]</code></li>
<li><p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 每250毫秒查询一次进程2764垃圾收集状况，一共查询20次</div><div class="line">jstat-gc 2764 250 20</div></pre></td></tr></table></figure>
</li>
<li><p>参数：主要分为3类：类装载、垃圾收集、运行<br>期编译状况</p>
<ul>
<li><code>-class</code>：监视类装载、卸载数量、总空间和类装载消耗的时间</li>
<li><code>-gc</code>：监视java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，GC时间合计等信息</li>
<li><code>-gccapacity</code>：    监视内容与<code>-gc</code>相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</li>
<li><code>-gcutil</code>：监视内容与<code>-gc</code>相同，但输出主要关注已使用空间占总空间的百分百</li>
<li><code>-gccause</code>：与<code>-gcutil</code>一样，但会额外输出上一次GC产生的原因</li>
<li><code>-gcnew</code>：监视新生代GC的状况</li>
<li><code>-gcnewcapacity</code>：监视内容与<code>-gcnew</code>相同，输出主要关注使用到的最大、最小空间</li>
<li><code>-gcold</code>：监视老年代GC的状况</li>
<li><code>-gcoldcapacity</code>：监视内容与<code>-gcold</code>相同，输出主要关注使用到的最大、最小空间</li>
<li><code>-gcpermcapacity</code>：输出永久代使用到的最大、最小空间</li>
<li><code>-compiler</code>：输出JIT编译过的方法、耗时等信息</li>
<li><code>-printcompilation</code>：输出已被JIT编译的方法</li>
</ul>
</li>
</ul>
<h1 id="jinfo（Configuration-Info-for-Java）"><a href="#jinfo（Configuration-Info-for-Java）" class="headerlink" title="jinfo（Configuration Info for Java）"></a>jinfo（Configuration Info for Java）</h1><p>Java配置信息工具，可实时查看和调整虚拟机各项参数。</p>
<ul>
<li>命令格式：<code>jinfo[option]pid</code></li>
<li>参数：<ul>
<li><code>-flag</code>：输出指定args参数的值</li>
<li><code>-flags</code>：不需要args参数，输出所有JVM参数的值</li>
<li><code>-sysprops</code>：输出系统属性，等同于System.getProperties()</li>
</ul>
</li>
</ul>
<h1 id="jmap（Memory-Map-for-Java）"><a href="#jmap（Memory-Map-for-Java）" class="headerlink" title="jmap（Memory Map for Java）"></a>jmap（Memory Map for Java）</h1><p>Java内存映像工具用于生成堆转储快照（dump文件）</p>
<ul>
<li>几种获得dump文件的方式<ul>
<li>jmap命令</li>
<li>-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件</li>
<li>-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件</li>
<li>在Linux系统下通过<code>Kill-3</code>命令发送进程退出信号也能拿到dump文件</li>
</ul>
</li>
<li>命令格式：<code>jmap[option]vmid</code></li>
<li>参数：<ul>
<li><code>-dump</code>：生成堆转储快照</li>
<li><code>-finalizerinfo</code>：显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li>
<li><code>-heap</code>：显示Java堆详细信息</li>
<li><code>-histo</code>：显示堆中对象的统计信息</li>
<li><code>-permstat</code>：以CLassLoader为统计口径显示永久代内存状态</li>
<li><code>-F</code>：当-dump没有响应时，强制生成dump快照</li>
</ul>
</li>
</ul>
<h1 id="jhat（JVM-Heap-Analysis-Tool）"><a href="#jhat（JVM-Heap-Analysis-Tool）" class="headerlink" title="jhat（JVM Heap Analysis Tool）"></a>jhat（JVM Heap Analysis Tool）</h1><p>与jmap搭配使用，用来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p>
<ul>
<li>命令格式：<code>jhat [dumpfile]</code></li>
<li>不推荐使用此命令，有2个原因：<ul>
<li>一般不会直接在服务器上分析dump文件，浪费服务器资源。</li>
<li>分析功能简陋，推荐用专业的可视化分析工具，比如VisualVM</li>
</ul>
</li>
</ul>
<h1 id="jstack（Stack-Trace-for-Java）"><a href="#jstack（Stack-Trace-for-Java）" class="headerlink" title="jstack（Stack Trace for Java）"></a>jstack（Stack Trace for Java）</h1><p>Java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。</p>
<p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p>
<p>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<ul>
<li>命令格式：<code>jstack[option]vmid</code></li>
<li>参数：<ul>
<li><code>-F</code>：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li><code>-l</code>：除堆栈外，显示关于锁的附加信息</li>
<li><code>-m</code>：如果调用本地方法，可显示C/C++的堆栈</li>
</ul>
</li>
<li>在JDK 1.5中，<code>java.lang.Thread</code>类新增了一个<code>getAllStackTraces()</code>方法用于获取虚拟机中所有线程的StackTraceElement对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;jps（JVM-Process-Status-Tool）&quot;&gt;&lt;a href=&quot;#jps（JVM-Process-Status-Tool）&quot; class=&quot;headerlink&quot; title=&quot;jps（JVM Process Status Tool）&quot;&gt;&lt;/a&gt;jps（JVM Process Status Tool）&lt;/h1&gt;&lt;p&gt;虚拟机进程状况工具，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（MainClass,main（）函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令格式：&lt;code&gt;jps[options][hostid]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt;：只输出LVMID，省略主类名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt;：输出虚拟机进程启动时传给主类main()函数的参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;：输出主类全名，如果进程执行的时jar包则输出jar路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;：输出虚拟机进程启动时的jvm参数
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（二）：垃圾收集算法</title>
    <link href="https://peijie-sh.github.io/2018/01/16/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://peijie-sh.github.io/2018/01/16/理解JVM（二）：垃圾收集算法/</id>
    <published>2018-01-16T07:25:12.000Z</published>
    <updated>2018-08-20T12:21:16.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断哪些对象需要被回收"><a href="#判断哪些对象需要被回收" class="headerlink" title="判断哪些对象需要被回收"></a>判断哪些对象需要被回收</h1><ul>
<li>引用计数算法：<ul>
<li>给对象中添加一个引用计数器，每当有一个地方引用时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>但是JVM没有使用此方法，因为此方法无法解决2个对象相互循环引用的问题。</li>
</ul>
</li>
<li>可达性分析算法：<ul>
<li>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<a id="more"></a></li>
</ul>
</li>
<li>在Java语言中，可作为GC Roots的对象包括下面几种：<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
</li>
</ul>
<h1 id="JDK1-2以后的引用分为4种，引用强度依次逐渐减弱"><a href="#JDK1-2以后的引用分为4种，引用强度依次逐渐减弱" class="headerlink" title="JDK1.2以后的引用分为4种，引用强度依次逐渐减弱"></a>JDK1.2以后的引用分为4种，引用强度依次逐渐减弱</h1><ul>
<li>强引用（Strong Reference）<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似<code>Object obj=new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 </li>
</ul>
</li>
<li>软引用（Soft Reference）<ul>
<li>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了<code>SoftReference</code>类来实现。 </li>
</ul>
</li>
<li>弱引用（Weak Reference）<ul>
<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了<code>WeakReference</code>类来实现。</li>
</ul>
</li>
<li>虚引用（Phantom Reference）<ul>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了<code>PhantomReference</code>类来实现。 </li>
</ul>
</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><ul>
<li>此方法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</li>
<li>主要两个不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 </li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641be7dcdba5403?w=813&amp;h=567&amp;f=png&amp;s=56126" alt=""></p>
<h2 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h2><ul>
<li>此方法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是可用内存变成原来的一半，代价较大。</li>
<li>此方法一般用在回收新生代，因为新生代的对象98%都是很快就会被回收，所以不用1:1划分，而是分为一块较大的<code>Eden空间</code>和2块较小的<code>Survivor空间</code>。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1:1，即新生代中可用内存为90%，只有10%被浪费。<br><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641beafe4849c59?w=806&amp;h=548&amp;f=png&amp;s=55172" alt=""><h2 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h2></li>
<li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</li>
<li>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641bf807020ed1e?w=801&amp;h=556&amp;f=png&amp;s=54150" alt=""></p>
<h2 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational  Collection）"></a>分代收集算法（Generational  Collection）</h2><ul>
<li>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判断哪些对象需要被回收&quot;&gt;&lt;a href=&quot;#判断哪些对象需要被回收&quot; class=&quot;headerlink&quot; title=&quot;判断哪些对象需要被回收&quot;&gt;&lt;/a&gt;判断哪些对象需要被回收&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引用计数算法：&lt;ul&gt;
&lt;li&gt;给对象中添加一个引用计数器，每当有一个地方引用时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;br&gt;但是JVM没有使用此方法，因为此方法无法解决2个对象相互循环引用的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可达性分析算法：&lt;ul&gt;
&lt;li&gt;这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK8和JDK9双版本共存</title>
    <link href="https://peijie-sh.github.io/2017/09/30/JDK8%E5%92%8CJDK9%E5%8F%8C%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98/"/>
    <id>https://peijie-sh.github.io/2017/09/30/JDK8和JDK9双版本共存/</id>
    <published>2017-09-30T02:11:25.000Z</published>
    <updated>2018-09-10T08:10:45.395Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4059338-19a112548aeefa7b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java9.jpg"></p>
<a id="more"></a>
<p>以前安装JDK，需要手动配置环境变量。JDK8多了自动配置环境变量，所以可以不用手动配置。<br>如果我已经装了JDK8，还想再装一个JDK9，安装完，自动配置的环境变量会指向JDK9版本。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>删除自动配置的环境变量<br>自动配置的环境变量是一个隐藏目录：<code>C:\ProgramData\Oracle\Java\javapath</code>，删掉这个目录下的3个exe文件，系统就无法匹配到了。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4059338-8a87044b407e014f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jdk.png"></p>
<ol>
<li>手动配置环境变量<br>自动匹配是匹配不到了，所以我们用老办法，手动配置环境变量即可。<br>这样，我们可以根据环境变量里配置的JDK版本去实现版本切换了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-19a112548aeefa7b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;java9.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://peijie-sh.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JDK" scheme="https://peijie-sh.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>搭建日志分析系统ELK</title>
    <link href="https://peijie-sh.github.io/2017/08/18/%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9FELK/"/>
    <id>https://peijie-sh.github.io/2017/08/18/搭建日志分析系统ELK/</id>
    <published>2017-08-18T06:11:43.000Z</published>
    <updated>2018-04-14T12:45:39.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4059338-cf6a458b1e4dc0e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="elasticsearch.jpg"></p>
<h1 id="日志分析组件3件套："><a href="#日志分析组件3件套：" class="headerlink" title="日志分析组件3件套："></a>日志分析组件3件套：</h1><ul>
<li>E：<code>Elasticsearch</code>是一个搜索引擎，基于<code>Lucene</code>，天然分布式，很容易水平扩展，屏蔽了复杂的分布式概念，对外提供<code>RESTful</code>API。</li>
<li>L：<code>Logstash</code>用于收集日志，写入<code>Elasticsearch</code>。</li>
<li>K：<code>Kibana</code>是一个展示层，基于NodeJS，可以图标形式展示数据，界面简洁。<a id="more"></a>
这3大组件，都可以在 <a href="https://www.elastic.co/cn/products" target="_blank" rel="external">这里</a> 直接下载。</li>
</ul>
<h1 id="搭建安装步骤："><a href="#搭建安装步骤：" class="headerlink" title="搭建安装步骤："></a>搭建安装步骤：</h1><ul>
<li><p>下载elasticsearch，解压后，运行<code>bin/elasticsearch -d</code>，以守护进程形式启动，打开localhost:9200会返回json信息如下，说明启动成功。<br><img src="http://upload-images.jianshu.io/upload_images/4059338-38c4534a2a73570c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json.png"></p>
</li>
<li><p>下载Logstash，解压，在/bin/config下创建一个配置文件<code>vi logstash.conf</code>。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">  tcp &#123;</div><div class="line">    host =&gt; <span class="string">"192.168.1.91"</span> <span class="comment"># 要监听的日志来源地址</span></div><div class="line">    port =&gt; 4567</div><div class="line">    mode =&gt; <span class="string">"server"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">  stdout&#123; codec =&gt; rubydebug &#125;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; [<span class="string">"192.168.1.91:9200"</span>]  <span class="comment"># elasticsearch中配置的host地址</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>指定配置文件并后台启动：<code>bin/logstash -f logstash.conf &amp;</code>。</li>
<li>在你的应用程序中配置日志输出到<code>Logstash</code>，比如<code>Logback.xml</code><ol>
<li>引入logstash-logback-encoder：<code>compile group: &#39;net.logstash.logback&#39;, name: &#39;logstash-logback-encoder&#39;, version: &#39;4.11&#39;</code></li>
<li>配置logback.xml</li>
</ol>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stash"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.1.91:4567<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- encoder is required --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileout"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stash"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>下载Kibana，解压后启动：<code>bin/kibana &amp;</code>，打开<code>localhost:5601</code>即可。</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>在安装Elasticsearch的时候，配置文件中我们把network.host改为0.0.0.0允许远程访问后，启动会报错，请按照 <a href="http://blog.csdn.net/u012246178/article/details/63253531" target="_blank" rel="external">如下操作</a>，放开linux的系统限制。</li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="external">Elasticsearch入门参考手册</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-cf6a458b1e4dc0e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;elasticsearch.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;日志分析组件3件套：&quot;&gt;&lt;a href=&quot;#日志分析组件3件套：&quot; class=&quot;headerlink&quot; title=&quot;日志分析组件3件套：&quot;&gt;&lt;/a&gt;日志分析组件3件套：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;E：&lt;code&gt;Elasticsearch&lt;/code&gt;是一个搜索引擎，基于&lt;code&gt;Lucene&lt;/code&gt;，天然分布式，很容易水平扩展，屏蔽了复杂的分布式概念，对外提供&lt;code&gt;RESTful&lt;/code&gt;API。&lt;/li&gt;
&lt;li&gt;L：&lt;code&gt;Logstash&lt;/code&gt;用于收集日志，写入&lt;code&gt;Elasticsearch&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;K：&lt;code&gt;Kibana&lt;/code&gt;是一个展示层，基于NodeJS，可以图标形式展示数据，界面简洁。
    
    </summary>
    
      <category term="NoSQL" scheme="https://peijie-sh.github.io/categories/NoSQL/"/>
    
    
      <category term="Logback" scheme="https://peijie-sh.github.io/tags/Logback/"/>
    
      <category term="Elasticsearch" scheme="https://peijie-sh.github.io/tags/Elasticsearch/"/>
    
      <category term="Logstash" scheme="https://peijie-sh.github.io/tags/Logstash/"/>
    
      <category term="Kibana" scheme="https://peijie-sh.github.io/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习笔记之新日期API</title>
    <link href="https://peijie-sh.github.io/2017/05/08/Java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%96%B0%E6%97%A5%E6%9C%9FAPI/"/>
    <id>https://peijie-sh.github.io/2017/05/08/Java8学习笔记之新日期API/</id>
    <published>2017-05-08T09:10:12.000Z</published>
    <updated>2017-06-24T12:19:27.316Z</updated>
    
    <content type="html"><![CDATA[<p>Java8对日期API做了改进，提供了许多好用的方法和接口。<br>首先，最基本也最重要的3个对象：</p>
<ul>
<li><code>LocalDate</code>：日期对象</li>
<li><code>LocalTime</code>：时间对象</li>
<li><code>LocalDateTime</code>：日期时间对象，是<code>LocalDate</code>和<code>LocalTime</code>的合集</li>
</ul>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>以上这3个对象，都各自有3种创建方式。</p>
<ol>
<li>通过<code>.now()</code>得到当前日期时间对象。</li>
<li>通过<code>.of()</code>直接指定年月日，时分秒。</li>
<li><code>LocalDate</code>和<code>LocalTime</code>通过解析字符串创建，<code>LocalDateTime</code>可以通过前2个对象创建。</li>
</ol>
<a id="more"></a>
<h2 id="LocalDate对象3种创建方式以及相关方法示例"><a href="#LocalDate对象3种创建方式以及相关方法示例" class="headerlink" title="LocalDate对象3种创建方式以及相关方法示例"></a>LocalDate对象3种创建方式以及相关方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDate</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">3</span>);</div><div class="line">    <span class="keyword">int</span> year = date.getYear();<span class="comment">// 2017</span></div><div class="line">    Month month = date.getMonth();<span class="comment">// MAY</span></div><div class="line">    <span class="keyword">int</span> day = date.getDayOfMonth();<span class="comment">// 3</span></div><div class="line">    DayOfWeek dow = date.getDayOfWeek();<span class="comment">// Wednesday</span></div><div class="line">    <span class="keyword">int</span> len = date.lengthOfMonth();<span class="comment">// 31</span></div><div class="line">    <span class="keyword">boolean</span> leap = date.isLeapYear();<span class="comment">// false</span></div><div class="line">    System.out.println(year + <span class="string">", "</span> + month + <span class="string">", "</span> + day + <span class="string">", "</span> + dow + <span class="string">", "</span> + len + <span class="string">", "</span> + leap);</div><div class="line"></div><div class="line">    LocalDate date2 = LocalDate.now();</div><div class="line">    <span class="keyword">int</span> year2 = date2.get(ChronoField.YEAR);<span class="comment">// 2017</span></div><div class="line">    <span class="keyword">int</span> month2 = date2.get(ChronoField.MONTH_OF_YEAR);<span class="comment">// 5</span></div><div class="line">    <span class="keyword">int</span> day2 = date2.get(ChronoField.DAY_OF_MONTH);<span class="comment">// 3</span></div><div class="line">    <span class="keyword">int</span> dow2 = date2.get(ChronoField.DAY_OF_WEEK);<span class="comment">// 3</span></div><div class="line">    System.out.println(year2 + <span class="string">", "</span> + month2 + <span class="string">", "</span> + day2 + <span class="string">", "</span> + dow2);</div><div class="line"></div><div class="line">    <span class="comment">// 写2017-3-18会报错，DateTimeParseException异常，可以传一个DateTimeFormatter自定义格式</span></div><div class="line">    LocalDate date3 = LocalDate.parse(<span class="string">"2017-03-18"</span>);</div><div class="line">    <span class="keyword">int</span> year3 = date3.get(ChronoField.YEAR);</div><div class="line">    <span class="keyword">int</span> month3 = date3.get(ChronoField.MONTH_OF_YEAR);</div><div class="line">    <span class="keyword">int</span> day3 = date3.get(ChronoField.DAY_OF_MONTH);</div><div class="line">    <span class="keyword">int</span> dow3 = date3.get(ChronoField.DAY_OF_WEEK);</div><div class="line">    System.out.println(year3 + <span class="string">", "</span> + month3 + <span class="string">", "</span> + day3 + <span class="string">", "</span> + dow3);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LocalTime对象3种创建方式以及相关方法示例"><a href="#LocalTime对象3种创建方式以及相关方法示例" class="headerlink" title="LocalTime对象3种创建方式以及相关方法示例"></a>LocalTime对象3种创建方式以及相关方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalTime time = LocalTime.of(<span class="number">11</span>, <span class="number">06</span>, <span class="number">23</span>);</div><div class="line">    <span class="keyword">int</span> hour = time.getHour();</div><div class="line">    <span class="keyword">int</span> minute = time.getMinute();</div><div class="line">    <span class="keyword">int</span> second = time.getSecond();</div><div class="line">    System.out.println(hour + <span class="string">":"</span> + minute + <span class="string">":"</span> + second);</div><div class="line"></div><div class="line">    LocalTime time2 = LocalTime.now();</div><div class="line">    <span class="keyword">int</span> hour2 = time2.get(ChronoField.HOUR_OF_DAY);</div><div class="line">    <span class="keyword">int</span> minute2 = time2.get(ChronoField.MINUTE_OF_HOUR);</div><div class="line">    <span class="keyword">int</span> second2 = time2.get(ChronoField.SECOND_OF_MINUTE);</div><div class="line">    System.out.println(hour2 + <span class="string">":"</span> + minute2 + <span class="string">":"</span> + second2);</div><div class="line"></div><div class="line">    <span class="comment">// 写13:5:43会报错，DateTimeParseException异常，可以传一个DateTimeFormatter自定义格式</span></div><div class="line">    LocalTime time3 = LocalTime.parse(<span class="string">"13:05:43"</span>);</div><div class="line">    <span class="keyword">int</span> hour3 = time3.get(ChronoField.HOUR_OF_DAY);</div><div class="line">    <span class="keyword">int</span> minute3 = time3.get(ChronoField.MINUTE_OF_HOUR);</div><div class="line">    <span class="keyword">int</span> second3 = time3.get(ChronoField.SECOND_OF_MINUTE);</div><div class="line">    System.out.println(hour3 + <span class="string">":"</span> + minute3 + <span class="string">":"</span> + second3);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LocalDateTime对象3种创建方式以及相关方法示例"><a href="#LocalDateTime对象3种创建方式以及相关方法示例" class="headerlink" title="LocalDateTime对象3种创建方式以及相关方法示例"></a>LocalDateTime对象3种创建方式以及相关方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date = LocalDate.now();</div><div class="line">    LocalTime time = LocalTime.now();</div><div class="line"></div><div class="line">    <span class="comment">// 创建LocalDateTime</span></div><div class="line">    LocalDateTime dateTime = LocalDateTime.of(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">53</span>, <span class="number">23</span>);</div><div class="line">    LocalDateTime dateTime2 = LocalDateTime.of(date, time);</div><div class="line">    LocalDateTime dateTime3 = date.atTime(<span class="number">11</span>, <span class="number">53</span>, <span class="number">23</span>);</div><div class="line">    LocalDateTime dateTime4 = date.atTime(time);</div><div class="line">    LocalDateTime dateTime6 = time.atDate(date);</div><div class="line"></div><div class="line">    <span class="comment">// 转化</span></div><div class="line">    LocalDate date2 = dateTime2.toLocalDate();</div><div class="line">    LocalTime time2 = dateTime2.toLocalTime();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="时间间隔对象"><a href="#时间间隔对象" class="headerlink" title="时间间隔对象"></a>时间间隔对象</h1><ul>
<li><code>Duration</code>：可以传2个localTime对象，localDateTime对象或者Instant对象</li>
<li><code>Period</code>：用年，月，日建模，可以传2个localDate对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">between</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//        Duration d1 = Duration.between(time1, time2);</span></div><div class="line"><span class="comment">//        Duration d2 = Duration.between(dateTime1, dateTime2);</span></div><div class="line"><span class="comment">//        Duration d3 = Duration.between(instant1, instant2);</span></div><div class="line">        Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>), LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</div><div class="line"></div><div class="line">        Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</div><div class="line">        Duration threeMinutes2 = Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES);</div><div class="line">        Period tenDays2 = Period.ofDays(<span class="number">10</span>);</div><div class="line">        Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</div><div class="line">        Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="修改日期时间对象"><a href="#修改日期时间对象" class="headerlink" title="修改日期时间对象"></a>修改日期时间对象</h1><h2 id="直接使用-with-来修改对应的年月日时分秒属性"><a href="#直接使用-with-来修改对应的年月日时分秒属性" class="headerlink" title="直接使用.with()来修改对应的年月日时分秒属性"></a>直接使用<code>.with()</code>来修改对应的年月日时分秒属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editDateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);<span class="comment">// 2014-03-18</span></div><div class="line">    LocalDate date2 = date1.withYear(<span class="number">2011</span>);<span class="comment">// 2011-03-18</span></div><div class="line">    LocalDate date3 = date2.withDayOfMonth(<span class="number">25</span>);<span class="comment">// 2011-03-25</span></div><div class="line">    LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);<span class="comment">// 2011-09-25</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在现有对象上做相对修改"><a href="#在现有对象上做相对修改" class="headerlink" title="在现有对象上做相对修改"></a>在现有对象上做相对修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editDateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);<span class="comment">// 2014-03-18</span></div><div class="line">    LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);<span class="comment">// 2014-03-25</span></div><div class="line">    LocalDate date3 = date2.minusYears(<span class="number">3</span>);<span class="comment">// 2011-03-25</span></div><div class="line">    LocalDate date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);<span class="comment">// 2011-09-25</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义修改日期"><a href="#自定义修改日期" class="headerlink" title="自定义修改日期"></a>自定义修改日期</h2><p>如果要对日期做一些复杂的修改，那么可以通过<code>TemporalAdjusters</code>接口实现复杂逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date1 = LocalDate.of(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">8</span>);<span class="comment">// 2017-05-08</span></div><div class="line">    LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));<span class="comment">// 2017-05-14</span></div><div class="line">    LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());<span class="comment">// 2017-05-31</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>jdk为我们实现了一些常用的方法：</p>
<ul>
<li>dayOfWeekInMonth：创建一个新的日期，它的值为同一个月中每一周的第几天</li>
<li>firstDayOfMonth：创建一个新的日期，它的值为当月的第一天</li>
<li>firstDayOfNextMonth：创建一个新的日期，它的值为下月的第一天</li>
<li>firstDayOfNextYear：创建一个新的日期，它的值为明年的第一天</li>
<li>firstDayOfYear：创建一个新的日期，它的值为当年的第一天</li>
<li>firstInMonth：创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的值</li>
<li>lastDayOfMonth：创建一个新的日期，它的值为当月的最后一天</li>
<li>lastDayOfNextMonth：创建一个新的日期，它的值为下月的最后一天</li>
<li>lastDayOfNextYear：创建一个新的日期，它的值为明年的最后一天</li>
<li>lastDayOfYear：创建一个新的日期，它的值为今年的最后一天</li>
<li>lastInMonth：创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的值</li>
<li>next/previous：创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期</li>
<li>nextOrSame/previousOrSame：创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期，如果该日期已经符合要求，直接返回该对象</li>
</ul>
<h1 id="自定义格式化输出日期"><a href="#自定义格式化输出日期" class="headerlink" title="自定义格式化输出日期"></a>自定义格式化输出日期</h1><p>新版本，我们拥有一个线程安全的类：<code>DateTimeFormatter</code><br>来看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">formatPrint</span><span class="params">()</span> </span>&#123;</div><div class="line">    LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</div><div class="line">    String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);<span class="comment">// 20140318</span></div><div class="line">    String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);<span class="comment">// 2014-03-18</span></div><div class="line"></div><div class="line">    LocalDate date1 = LocalDate.parse(<span class="string">"20140318"</span>, DateTimeFormatter.BASIC_ISO_DATE);</div><div class="line">    LocalDate date2 = LocalDate.parse(<span class="string">"2014-03-18"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</div><div class="line"></div><div class="line">    <span class="comment">// 自定义格式</span></div><div class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</div><div class="line">    String formattedDate = date.format(formatter);</div><div class="line">    System.out.println(formattedDate);<span class="comment">// 18/03/2014</span></div><div class="line">    LocalDate date3 = LocalDate.parse(formattedDate, formatter);</div><div class="line"></div><div class="line">    <span class="comment">// 带时区的日期(本地化)</span></div><div class="line">    DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(<span class="string">"d. MMMM yyyy"</span>, Locale.ITALIAN);</div><div class="line">    String formattedDate2 = date.format(italianFormatter); <span class="comment">// 18. marzo 2014</span></div><div class="line">    LocalDate date4 = LocalDate.parse(formattedDate2, italianFormatter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8对日期API做了改进，提供了许多好用的方法和接口。&lt;br&gt;首先，最基本也最重要的3个对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LocalDate&lt;/code&gt;：日期对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LocalTime&lt;/code&gt;：时间对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LocalDateTime&lt;/code&gt;：日期时间对象，是&lt;code&gt;LocalDate&lt;/code&gt;和&lt;code&gt;LocalTime&lt;/code&gt;的合集&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h1&gt;&lt;p&gt;以上这3个对象，都各自有3种创建方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;.now()&lt;/code&gt;得到当前日期时间对象。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;.of()&lt;/code&gt;直接指定年月日，时分秒。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LocalDate&lt;/code&gt;和&lt;code&gt;LocalTime&lt;/code&gt;通过解析字符串创建，&lt;code&gt;LocalDateTime&lt;/code&gt;可以通过前2个对象创建。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="java8" scheme="https://peijie-sh.github.io/tags/java8/"/>
    
      <category term="时间日期API" scheme="https://peijie-sh.github.io/tags/%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习笔记之Stream API</title>
    <link href="https://peijie-sh.github.io/2017/04/26/Java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BStream%20API/"/>
    <id>https://peijie-sh.github.io/2017/04/26/Java8学习笔记之Stream API/</id>
    <published>2017-04-26T03:28:37.000Z</published>
    <updated>2017-06-24T12:19:27.315Z</updated>
    
    <content type="html"><![CDATA[<p>Stream是Java8引入的一个重度使用lambda表达式的API。<br>Stream可以用流的方式处理数据集合，在Java8之前，我们处理这些集合，是需要迭代器的，比如iterator，这是外部迭代；而Stream是内部迭代，我们不用关心集合内部元素是如何迭代的，计算机会自动帮我们选择最适合的实现方式。</p>
<h1 id="如何创建一个流"><a href="#如何创建一个流" class="headerlink" title="如何创建一个流"></a>如何创建一个流</h1><ol>
<li>最常见的，有一个集合对象<code>List&lt;String&gt; strs = Arrays.asList(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;);</code>，直接调用<code>strs.stream()</code>就得到一个<code>Stream&lt;String&gt;</code>的流。<br>如果想使用并行流增加性能，请使用<code>strs.parallelStream()</code>，或<code>strs.stream().parallel()</code>。</li>
<li>由值创建：<code>Stream&lt;String&gt; stream = Stream.of(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;);</code><a id="more"></a></li>
<li><p>由数组创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</div><div class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</div></pre></td></tr></table></figure>
</li>
<li><p>由文件创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 统计文本文件中有多少个不同的单词</span></div><div class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</div><div class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"data.txt"</span>), Charset.defaultCharset())) &#123;</div><div class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)))</div><div class="line">            .distinct()</div><div class="line">            .count();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由函数生成流：<code>Stream.iterate()</code>和<code>Stream.generate()</code>可以生产无限流，即元素有无穷多个。一般来说，应该使用limit(n)来对这种流加以限制，以避免产生无穷多个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> </span>&#123;</div><div class="line">    Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a>Stream常用方法</h1><blockquote>
<p>Stream API 支持两种类型的操作：中间操作（如filter或map）和终端操作（如count、findFirst、forEach和reduce）。</p>
</blockquote>
<p>我用一个筛选菜单的需求作为示例。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vegetarian;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type type;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dish</span><span class="params">(String name, <span class="keyword">boolean</span> vegetarian, <span class="keyword">int</span> calories, Type type)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.vegetarian = vegetarian;</div><div class="line">            <span class="keyword">this</span>.calories = calories;</div><div class="line">            <span class="keyword">this</span>.type = type;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVegetarian</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> vegetarian;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalories</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> calories;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> type;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;MEAT, FISH, OTHER&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Dish&gt; <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Arrays.asList(</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Type.MEAT),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Type.MEAT),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Type.MEAT),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Type.OTHER),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"rice"</span>, <span class="keyword">true</span>, <span class="number">350</span>, Type.OTHER),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Type.OTHER),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"pizza"</span>, <span class="keyword">true</span>, <span class="number">550</span>, Type.OTHER),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"prawns"</span>, <span class="keyword">false</span>, <span class="number">300</span>, Type.FISH),</div><div class="line">                <span class="keyword">new</span> Dish(<span class="string">"salmon"</span>, <span class="keyword">false</span>, <span class="number">450</span>, Type.FISH));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="过滤筛选"><a href="#过滤筛选" class="headerlink" title="过滤筛选"></a>过滤筛选</h2><blockquote>
<p>谓词：返回boolean的函数</p>
</blockquote>
<ul>
<li><p>filter()：接受一个谓词，返回符合条件的元素集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    List&lt;Dish&gt; vegetarianMenu = menu.stream()</div><div class="line">            .filter(Dish::isVegetarian)</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    Assert.assertEquals(<span class="number">4</span>, vegetarianMenu.size());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>distinct()：返回集合中各异的元素集合(去重)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinct</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">    numbers.stream().distinct().forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>limit()：截取流中指定数量的元素，返回一个不超过给定长度的流。如果流是有序的，则最多会返回前n个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">``` java</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;Dish&gt; menu = init();</div><div class="line">        menu.stream()</div><div class="line">                .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</div><div class="line">                .limit(<span class="number">3</span>)</div><div class="line">                .forEach(System.out::println);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>skip()：跳过指定数量元素，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skip</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    menu.stream()</div><div class="line">            .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</div><div class="line">            .limit(<span class="number">3</span>)</div><div class="line">            .skip(<span class="number">2</span>)</div><div class="line">            .forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul>
<li><p>map()：接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    List&lt;String&gt; dishNames = menu.stream().map(m -&gt; m.getName()).collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flatMap()：一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流，即扁平化为一个流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    String[] arrayOfWords = &#123;<span class="string">"Goodbye"</span>, <span class="string">"World"</span>&#125;;</div><div class="line">    List&lt;String&gt; words = Arrays.asList(arrayOfWords);</div><div class="line">    words.stream()</div><div class="line">            .map(w -&gt; w.split(<span class="string">""</span>))</div><div class="line">            .flatMap(Arrays::stream)</div><div class="line">            .distinct()</div><div class="line">            .forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面例子中，<code>split()</code>得到的是String[] 而不是String，因此各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，变为一个流。</p>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>匹配比较简单，返回一个boolean</p>
<ul>
<li>anyMatch()：至少匹配一个</li>
<li>allMatch()：全部匹配</li>
<li>noneMatch()：全部不匹配，和allMatch相反</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    Assert.assertEquals(<span class="keyword">true</span>, menu.stream().anyMatch(Dish::isVegetarian));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allMatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    Assert.assertEquals(<span class="keyword">true</span>, menu.stream().allMatch(d -&gt; d.getCalories() &lt; <span class="number">1000</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noneMatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    Assert.assertEquals(<span class="keyword">true</span>, menu.stream().noneMatch(d -&gt; d.getCalories() &gt;= <span class="number">1000</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找有2个方法：<code>findFirst()</code>和<code>findAny()</code>，返回一个<code>Optional&lt;T&gt;</code>集合。<br>如果你不关心返回的元素是哪个，请使用<code>findAny()</code>，因为它在使用并行流时限制较少。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">    Optional&lt;Integer&gt; firstSquareDivisibleByThree =</div><div class="line">            someNumbers.stream()</div><div class="line">                    .map(x -&gt; x * x)</div><div class="line">                    .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">                    .findFirst(); <span class="comment">// 9</span></div><div class="line">    System.out.println(firstSquareDivisibleByThree.get());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAny</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">    Optional&lt;Integer&gt; firstSquareDivisibleByThree =</div><div class="line">            someNumbers.stream()</div><div class="line">                    .map(x -&gt; x * x)</div><div class="line">                    .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">                    .findAny(); <span class="comment">// 9</span></div><div class="line">    System.out.println(firstSquareDivisibleByThree.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>归约在汇总结合内所有数据的时候使用。比如求 max，min，sum。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">    <span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</div><div class="line">    System.out.println(sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h1><p>流在内部迭代的过程中，对基本类型会自动装箱和拆箱。为了避免不需要的装箱拆箱，Java8提供了<code>IntStream</code>、<code>DoubleStream</code>和<code>LongStream</code></p>
<ul>
<li>普通流转特化流：mapToInt(), mapToLong(), mapToDouble()</li>
<li>特化流转普通流：boxed()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boxedStream</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Dish&gt; menu = init();</div><div class="line">    <span class="comment">// 特化</span></div><div class="line">    IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</div><div class="line">    <span class="comment">// 转回普通Stream</span></div><div class="line">    Stream&lt;Integer&gt; stream = intStream.boxed();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 8引入了两个可以用于IntStream和LongStream的静态方法，用于生成给定范围的数字流：</p>
<ul>
<li>range(min, max)：随机生成的数字不包含max，即(min, max)</li>
<li>rangeClosed(min, max)：随机生成的数字包含max，即(min, max]</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stream是Java8引入的一个重度使用lambda表达式的API。&lt;br&gt;Stream可以用流的方式处理数据集合，在Java8之前，我们处理这些集合，是需要迭代器的，比如iterator，这是外部迭代；而Stream是内部迭代，我们不用关心集合内部元素是如何迭代的，计算机会自动帮我们选择最适合的实现方式。&lt;/p&gt;
&lt;h1 id=&quot;如何创建一个流&quot;&gt;&lt;a href=&quot;#如何创建一个流&quot; class=&quot;headerlink&quot; title=&quot;如何创建一个流&quot;&gt;&lt;/a&gt;如何创建一个流&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;最常见的，有一个集合对象&lt;code&gt;List&amp;lt;String&amp;gt; strs = Arrays.asList(&amp;quot;Java 8 &amp;quot;, &amp;quot;Lambdas &amp;quot;, &amp;quot;In &amp;quot;, &amp;quot;Action&amp;quot;);&lt;/code&gt;，直接调用&lt;code&gt;strs.stream()&lt;/code&gt;就得到一个&lt;code&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;的流。&lt;br&gt;如果想使用并行流增加性能，请使用&lt;code&gt;strs.parallelStream()&lt;/code&gt;，或&lt;code&gt;strs.stream().parallel()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由值创建：&lt;code&gt;Stream&amp;lt;String&amp;gt; stream = Stream.of(&amp;quot;Java 8 &amp;quot;, &amp;quot;Lambdas &amp;quot;, &amp;quot;In &amp;quot;, &amp;quot;Action&amp;quot;);&lt;/code&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="java8" scheme="https://peijie-sh.github.io/tags/java8/"/>
    
      <category term="Stream API" scheme="https://peijie-sh.github.io/tags/Stream-API/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习笔记之Lambda表达式</title>
    <link href="https://peijie-sh.github.io/2017/04/19/Java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://peijie-sh.github.io/2017/04/19/Java8学习笔记之Lambda表达式/</id>
    <published>2017-04-19T08:40:34.000Z</published>
    <updated>2017-06-24T12:19:27.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4059338-39a526e6dbd5707d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lambda.jpg"><br>使用Lambda表达式，我们可以很简洁地传递代码（通常是匿名函数）。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>Lambda表达式主要分为三部分：参数列表，箭头，Lambda 主体</p>
<a id="more"></a>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>(parameters) -&gt; expression</li>
<li>(parameters) -&gt; { statements; }</li>
</ul>
<p>如果表达式只有一行，用第一种，多行用第二种。</p>
<p>Java8中，标注了<code>@FunctionalInterface</code>，表明这个接口将是一个函数式接口，它里面只能有一个抽象方法。</p>
<h1 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h1><p>JDK已经为我们提供了很多常用的函数式接口：</p>
<ul>
<li>Predicate：<code>java.util.function.Predicate&lt;T&gt;</code>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。在需要表示一个涉及类型T的布尔表达式时可以使用。</li>
<li>Consumer：<code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。</li>
<li>Supplier：<code>java.util.function.Supplier&lt;T&gt;</code>不接受对象，返回一个泛型对象T。在需要new一个对象实例时可以使用。</li>
<li>Function：<code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口。</li>
</ul>
<h1 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h1><p>我们知道，泛型只能绑定到引用类型的对象。因此，在使用泛型绑定基本类型的时候，Java会为我们自动装箱和拆箱，但这是会消耗性能的。<br>如果输入和输出都是基本类型时，Java8为我们提供了新的函数式接口，以避免自动装箱拆箱。</p>
<p>简单列举一部分：</p>
<ul>
<li>Predicate：<code>IntPredicate</code>, <code>LongPredicate</code>, <code>DoublePredicate</code></li>
<li>Consumer：<code>IntConsumer</code>,<code>LongConsumer</code>, <code>DoubleConsumer</code></li>
<li>Supplier：<code>BooleanSupplier</code>, <code>IntSupplier</code>, <code>LongSupplier</code>, <code>DoubleSupplier</code></li>
<li>Function：<code>IntFunction&lt;R&gt;</code>,<code>LongToDoubleFunction</code>,<code>ToLongFunction&lt;T&gt;</code></li>
</ul>
<p>从命名可以轻易看出从什么类型转成什么类型，可以在<code>java.util.function</code>包下查看所有接口。</p>
<h1 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h1><p>在使用lambda时，主体代码块内允许使用的外部变量。但是，不允许改变外部变量。这些变量应该声明为<code>final</code>或者事实上是<code>final</code>的（即之后代码中不会改变）</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用主要有三类：</p>
<ul>
<li>指向静态方法的方法引用<ul>
<li>Lambda: <code>(args) -&gt; ClassName.staticMethod(args)</code></li>
<li>方法引用：<code>ClassName :: staticMethod</code></li>
</ul>
</li>
<li>指向任意类型实例方法的方法引用<ul>
<li>Lambda: <code>(arg0, rest) -&gt; arg0.instanceMethod(rest)</code></li>
<li>方法引用：<code>ClassName :: instanceMethod</code>(arg0 是 ClassName 类型的)</li>
</ul>
</li>
<li>指向现有对象的实例方法的方法引用<ul>
<li>Lambda: <code>(args) -&gt; expr.instanceMethod(args)</code></li>
<li>方法引用：<code>expr :: intanceMethod</code></li>
</ul>
</li>
</ul>
<p>除此之外，还有构造函数引用：<code>ClassName :: new</code><br>比如用Map来将构造函数映射到字符串值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Map&lt;String, Function&lt;Integer, Fruit&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    map.put(<span class="string">"apple"</span>, Apple::<span class="keyword">new</span>);</div><div class="line">    map.put(<span class="string">"orange"</span>, Orange::<span class="keyword">new</span>);</div><div class="line">    <span class="comment">// etc...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">giveMeFruit</span><span class="params">(String fruit, Integer weight)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.get(fruit.toLowerCase()).apply(weight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="复合-Lambda-表达式"><a href="#复合-Lambda-表达式" class="headerlink" title="复合 Lambda 表达式"></a>复合 Lambda 表达式</h1><p>Comparator、Predicate和Function等函数式接口都有几个可以用来结Lambda表达式的默认方法。</p>
<h2 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h2><ol>
<li><p>普通排序<code>comparing()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);</div></pre></td></tr></table></figure>
</li>
<li><p>逆序<code>reversed()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed());</div></pre></td></tr></table></figure>
</li>
<li><p>比较器链<code>thenComparing()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inventory.sort(comparing(Apple::getWeight).reversed()</div><div class="line">    .thenComparing(Apple::getCountry));</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h2><p>3个方法增强已有的Predicate接口：</p>
<ul>
<li><code>and</code>：与</li>
<li><code>or</code>：或</li>
<li><code>negate</code>：非</li>
</ul>
<p><strong>请注意，and和or方法是按照在表达式链中的位置，从左向右确定优先级的。</strong>因此，a.or(b).and(c)可以看作(a || b) &amp;&amp; c。</p>
<h2 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h2><p>Function接口有<code>andThen</code>和<code>compose</code>两个默认方法，它们都会返回Function的一个实例。</p>
<p>举个例子：<br>有2个函数，一个加1，一个乘2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>; <span class="comment">// f(x)=x+1</span></div><div class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>; <span class="comment">// g(x)=2x</span></div></pre></td></tr></table></figure></p>
<ol>
<li><p><code>andThen()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g); <span class="comment">// g(f(x))</span></div><div class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>compose()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; h = f.compose(g); <span class="comment">// f(g(x))</span></div><div class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-39a526e6dbd5707d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Lambda.jpg&quot;&gt;&lt;br&gt;使用Lambda表达式，我们可以很简洁地传递代码（通常是匿名函数）。&lt;/p&gt;
&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;p&gt;Lambda表达式主要分为三部分：参数列表，箭头，Lambda 主体&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="Lambda表达式" scheme="https://peijie-sh.github.io/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="https://peijie-sh.github.io/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习笔记之行为参数化</title>
    <link href="https://peijie-sh.github.io/2017/04/19/Java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://peijie-sh.github.io/2017/04/19/Java8学习笔记之行为参数化/</id>
    <published>2017-04-19T05:10:12.000Z</published>
    <updated>2017-06-24T12:19:27.316Z</updated>
    
    <content type="html"><![CDATA[<p>用一个例子说明<code>行为参数化</code>带来的变化 - 从苹果仓库中筛选苹果</p>
<h1 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h1><p>从一个苹果集合中选出绿的苹果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; inventory)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple : inventory) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.getColor()) &#123;</div><div class="line">                result.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h1><p>这时，如果需求变了，要从集合中选出红苹果，我们会这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApplesByColor</span><span class="params">(List&lt;Apple&gt; inventory, String color)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple : inventory) &#123;</div><div class="line">            <span class="keyword">if</span> (apple.getColor().equals(color)) &#123;</div><div class="line">                result.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后传入颜色参数来筛选<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; apples = filterApplesByColor(inventory, <span class="string">"red"</span>);</div></pre></td></tr></table></figure></p>
<h1 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h1><p>但是，如果现在要选出重量超过150g的苹果呢？在方法参数列表中多加一个weight么？<br>你会发现我们所有的代码，只有if判断中的条件发生了变化，这违反了DRY原则(Don’t Repeat Yourself)。</p>
<p>所以，我们把整个具体行为作为参数来传递，这样，方法体本身的代码就可以复用了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"green"</span>.equals(apple.getColor());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, ApplePredicate p)</span> </span>&#123;</div><div class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Apple apple : inventory) &#123;</div><div class="line">        <span class="keyword">if</span> (p.test(apple)) &#123;</div><div class="line">            result.add(apple);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们可以很灵活的调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, <span class="keyword">new</span> AppleHeavyWeightPredicate());</div></pre></td></tr></table></figure></p>
<h1 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h1><p>其实，接口的具体实现，我们只会用到一次。所以，我们可以改成匿名类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; redApples = filterApples(inventory, <span class="keyword">new</span> ApplePredicate() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.getColor());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>现在，代码已经变得非常简洁和灵活了。</p>
<h1 id="版本5"><a href="#版本5" class="headerlink" title="版本5"></a>版本5</h1><p>从Java8开始，我们可以利用Lambda表达式，进一步改进代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; <span class="string">"red"</span>.equals(apple.getColor()));</div></pre></td></tr></table></figure></p>
<p>现在，调用方法，我们只要一行代码，而且代码的可读性非常好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用一个例子说明&lt;code&gt;行为参数化&lt;/code&gt;带来的变化 - 从苹果仓库中筛选苹果&lt;/p&gt;
&lt;h1 id=&quot;版本1&quot;&gt;&lt;a href=&quot;#版本1&quot; class=&quot;headerlink&quot; title=&quot;版本1&quot;&gt;&lt;/a&gt;版本1&lt;/h1&gt;&lt;p&gt;从一个苹果集合中选出绿的苹果&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; List&amp;lt;Apple&amp;gt; &lt;span class=&quot;title&quot;&gt;filterGreenApples&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Apple&amp;gt; inventory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List&amp;lt;Apple&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Apple&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Apple apple : inventory) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;.equals(apple.getColor()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                result.add(apple);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="Lambda表达式" scheme="https://peijie-sh.github.io/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="java8" scheme="https://peijie-sh.github.io/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>HTML转图片利器：wkhtmltox</title>
    <link href="https://peijie-sh.github.io/2017/04/01/HTML%E8%BD%AC%E5%9B%BE%E7%89%87%E5%88%A9%E5%99%A8%EF%BC%9Awkhtmltox/"/>
    <id>https://peijie-sh.github.io/2017/04/01/HTML转图片利器：wkhtmltox/</id>
    <published>2017-04-01T06:07:22.000Z</published>
    <updated>2018-09-10T08:11:35.874Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>wkhtmltox</code>，是一个可以把HTML转换为图片和pdf的工具。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4059338-27a3b4979a3084c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wkhtmltox.jpg"></p>
<p>不多介绍了，详见官网 <a href="https://wkhtmltopdf.org/" target="_blank" rel="external">https://wkhtmltopdf.org/</a></p>
<a id="more"></a>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>下载下来是tar.xz文件，首先解压：<br><code>tar -vxf wkhtmltox-0.12.4_linux-generic-amd64.tar.xz</code></p>
</li>
<li><p>解压得到一个目录wkhtmltox，把wkhtmltoimage和wkhtmltopdf复制到<code>/usr/bin</code>目录，更改所有者，并增加可执行属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo cp wkhtmltox/bin/wkhtmltopdf /usr/bin/</div><div class="line">sudo cp wkhtmltox/bin/wkhtmltoimage /usr/bin/</div><div class="line">sudo chown root:root /usr/bin/wkhtmltopdf</div><div class="line">sudo chown root:root /usr/bin/wkhtmltoimage</div><div class="line">sudo chmod +x /usr/bin/wkhtmltopdf</div><div class="line">sudo chmod +x /usr/bin/wkhtmltoimage</div></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
</li>
</ol>
<p>有时候为了让程序可以执行这个命令，可能需要配置环境变量</p>
<ul>
<li>编辑配置文件 <code>vi .bashrc</code></li>
<li>添加环境变量 <code>export PATH=$PATH:/opt/wkhtmltox/bin</code></li>
<li>让修改生效 <code>source .bashrc</code>让修改生效</li>
</ul>
<p>如果网页上的中文，转成图片后变成乱码方块，请安装相关字体 :)</p>
<h1 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h1><p>执行<code>wkhtmltoimage www.bing.com bing.png</code>，就会在当前目录下生成了一张png图片。<br><img src="http://upload-images.jianshu.io/upload_images/4059338-b81b7a7129404297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bing.png"></p>
<p>这个命令还可以增加一些参数，比如常用的设置宽高，图片质量等参数<br>执行<code>wkhtmltoimage --crop-w 410 --width 410 --quality 50 www.bing.com bing2.png</code>看看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4059338-3c6b126b35acc5f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bing2.png"></p>
<p>说明:</p>
<ul>
<li><code>--crop-w 410</code>：截图宽度410px</li>
<li><code>--width 410</code>：浏览器模拟宽度410px</li>
<li><code>--quality 50</code>：图片质量(这个值越大，图片质量越高，当然文件也会比较大)</li>
</ul>
<p>还有更多参数用法，请 <code>wkhtmltoimage -h</code>查看。<br>HTML转pdf同理，<code>wkhtmltopdf -h</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;wkhtmltox&lt;/code&gt;，是一个可以把HTML转换为图片和pdf的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-27a3b4979a3084c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;wkhtmltox.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;不多介绍了，详见官网 &lt;a href=&quot;https://wkhtmltopdf.org/&quot;&gt;https://wkhtmltopdf.org/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常记录" scheme="https://peijie-sh.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="wkhtmltox" scheme="https://peijie-sh.github.io/tags/wkhtmltox/"/>
    
      <category term="Linux" scheme="https://peijie-sh.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中使用Redis实现缓存</title>
    <link href="https://peijie-sh.github.io/2017/03/30/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98/"/>
    <id>https://peijie-sh.github.io/2017/03/30/SpringBoot中使用Redis实现缓存/</id>
    <published>2017-03-30T09:11:13.000Z</published>
    <updated>2018-04-14T12:45:39.733Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Data Redis为我们封装了Redis客户端的各种操作，简化使用。</p>
<ul>
<li>当Redis当做数据库或者消息队列来操作时，我们一般使用RedisTemplate来操作</li>
<li>当Redis作为缓存使用时，我们可以将它作为Spring Cache的实现，直接通过注解使用</li>
</ul>
<p>关于RedisTemplate的使用可参考：<a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="external">http://blog.didispace.com/springbootredis/</a></p>
<h1 id="下面总结使用Redis作为缓存"><a href="#下面总结使用Redis作为缓存" class="headerlink" title="下面总结使用Redis作为缓存"></a>下面总结使用Redis作为缓存</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>SpringBoot从1.4版本开始，<code>spring-boot-starter-redis</code>依赖改名了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  redis:</span></div><div class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line"><span class="attr">    port:</span> <span class="number">6379</span></div><div class="line"><span class="attr">    timeout:</span> <span class="number">0</span></div><div class="line"><span class="attr">    database:</span> <span class="number">0</span></div><div class="line"><span class="attr">    pool:</span></div><div class="line"><span class="attr">      max-active:</span> <span class="number">8</span></div><div class="line"><span class="attr">      max-wait:</span> <span class="bullet">-1</span></div><div class="line"><span class="attr">      max-idle:</span> <span class="number">8</span></div><div class="line"><span class="attr">      min-idle:</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这样，SpringBoot将会自动配置redis，注入相关bean，我们就可以使用<code>@CacheConfig</code>，<code>@Cacheable</code>，<code>@CachePut</code>，<code>@CacheEvict</code>了。</p>
<h1 id="使用Cache注解时的问题"><a href="#使用Cache注解时的问题" class="headerlink" title="使用Cache注解时的问题"></a>使用Cache注解时的问题</h1><p>缓存对象集合中，缓存是以key-value形式保存的。当不指定缓存的key时，SpringBoot会使用<code>SimpleKeyGenerator</code>生成key。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> generateKey(params);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Generate a key based on the specified parameters.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generateKey</span><span class="params">(Object... params)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (params.length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> SimpleKey.EMPTY;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (params.length == <span class="number">1</span>) &#123;</div><div class="line">			Object param = params[<span class="number">0</span>];</div><div class="line">			<span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; !param.getClass().isArray()) &#123;</div><div class="line">				<span class="keyword">return</span> param;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleKey(params);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleKey</span><span class="params">(Object... elements)</span> </span>&#123;</div><div class="line">	Assert.notNull(elements, <span class="string">"Elements must not be null"</span>);</div><div class="line">	<span class="keyword">this</span>.params = <span class="keyword">new</span> Object[elements.length];</div><div class="line">	System.arraycopy(elements, <span class="number">0</span>, <span class="keyword">this</span>.params, <span class="number">0</span>, elements.length);</div><div class="line">	<span class="keyword">this</span>.hashCode = Arrays.deepHashCode(<span class="keyword">this</span>.params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看源码可以发现，它是使用方法参数组合生成的一个key。<br><strong>此时有一个问题：</strong><br>如果2个方法，参数是一样的，但执行逻辑不同，那么将会导致执行第二个方法时命中第一个方法的缓存。<br>解决办法是在<code>@Cacheable</code>注解参数中指定key，或者自己实现一个<code>KeyGenerator</code>，在注解中指定KeyGenerator。<br>但是如果这样的情况很多，每一个都要指定key、KeyGenerator很麻烦。</p>
<p>Spring同样提供了方案：继承<code>CachingConfigurerSupport</code>并重写<code>keyGenerator()</code></p>
<p>下面贴出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableCaching</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisConnectionFactory jedisConnectionFactory;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringRedisTemplate redisTemplate = <span class="keyword">new</span> StringRedisTemplate(jedisConnectionFactory);</div><div class="line"></div><div class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</div><div class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</div><div class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</div><div class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</div><div class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</div><div class="line"></div><div class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</div><div class="line">        redisTemplate.afterPropertiesSet();</div><div class="line">        <span class="keyword">return</span> redisTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        String[] cacheNames = &#123;<span class="string">"app_default"</span>, <span class="string">"users"</span>, <span class="string">"blogs"</span>, <span class="string">"goods"</span>, <span class="string">"configs"</span>, <span class="string">"info"</span>&#125;;</div><div class="line">        RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate(), Arrays.asList(cacheNames));</div><div class="line">        redisCacheManager.setDefaultExpiration(<span class="number">86400</span>);</div><div class="line">        <span class="keyword">return</span> redisCacheManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">cache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cacheManager().getCache(<span class="string">"app_default"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (target, method, objects) -&gt; &#123;</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            sb.append(target.getClass().getName());</div><div class="line">            sb.append(<span class="string">"::"</span> + method.getName() + <span class="string">":"</span>);</div><div class="line">            <span class="keyword">for</span> (Object obj : objects) &#123;</div><div class="line">                sb.append(obj.toString());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，缓存的key是包名+方法名+参数列表，这样就很难会冲突了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Data Redis为我们封装了Redis客户端的各种操作，简化使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当Redis当做数据库或者消息队列来操作时，我们一般使用RedisTemplate来操作&lt;/li&gt;
&lt;li&gt;当Redis作为缓存使用时，我们可以将它作为Spring Cache的实现，直接通过注解使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于RedisTemplate的使用可参考：&lt;a href=&quot;http://blog.didispace.com/springbootredis/&quot;&gt;http://blog.didispace.com/springbootredis/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;下面总结使用Redis作为缓存&quot;&gt;&lt;a href=&quot;#下面总结使用Redis作为缓存&quot; class=&quot;headerlink&quot; title=&quot;下面总结使用Redis作为缓存&quot;&gt;&lt;/a&gt;下面总结使用Redis作为缓存&lt;/h1&gt;&lt;h2 id=&quot;引入依赖&quot;&gt;&lt;a href=&quot;#引入依赖&quot; class=&quot;headerlink&quot; title=&quot;引入依赖&quot;&gt;&lt;/a&gt;引入依赖&lt;/h2&gt;&lt;p&gt;SpringBoot从1.4版本开始，&lt;code&gt;spring-boot-starter-redis&lt;/code&gt;依赖改名了。&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.5.2.RELEASE&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://peijie-sh.github.io/categories/Spring/"/>
    
    
      <category term="SpringBoot" scheme="https://peijie-sh.github.io/tags/SpringBoot/"/>
    
      <category term="Cache" scheme="https://peijie-sh.github.io/tags/Cache/"/>
    
      <category term="Redis" scheme="https://peijie-sh.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>手动安装redis-3.2.8的详细步骤</title>
    <link href="https://peijie-sh.github.io/2017/03/30/%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85redis-3.2.8%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
    <id>https://peijie-sh.github.io/2017/03/30/手动安装redis-3.2.8的详细步骤/</id>
    <published>2017-03-30T02:40:27.000Z</published>
    <updated>2018-09-10T08:14:18.242Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS6.7使用yum安装有时候没有比较新的版本，所以手动安装，下面记录一下步骤。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4059338-13f399d148cd1ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis"></p>
<h1 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h1><p>以3.2.8为例，附上地址：<a href="https://redis.io/" target="_blank" rel="external">redis-3.2.8.tar.gz</a></p>
<a id="more"></a>
<h1 id="解压，编译，安装redis"><a href="#解压，编译，安装redis" class="headerlink" title="解压，编译，安装redis"></a>解压，编译，安装redis</h1><ul>
<li>解压：<code>tar -zxvf redis-3.2.8.tar.gz</code></li>
<li>进入目录：<code>cd redis-3.2.8</code></li>
<li>编译：<code>make &amp;&amp; make install</code></li>
<li><p>创建相关目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir -p /opt/redis-3.2.8/bin</div><div class="line">mkdir -p /opt/redis-3.2.8/log</div><div class="line">mkdir -p /opt/redis-3.2.8/pid</div><div class="line">mkdir -p /opt/redis-3.2.8/db</div></pre></td></tr></table></figure>
</li>
<li><p>将编译后的可执行文件复制到自己的安装目录：<code>ln -s /usr/local/bin/redis-* /opt/redis-3.2.8/bin</code></p>
</li>
<li>复制配置文件到安装目录：<code>cp redis.conf /opt/redis-3.2.8/</code></li>
</ul>
<h1 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h1><ul>
<li>编辑redis.conf：<code>cd /opt/redis-3.2.8</code>，<code>vi redis.conf</code><ul>
<li>redis默认只允许本机连接，所以注释掉这行配置就可以远程访问：<code>\# bind 127.0.0.1</code></li>
<li>redis3.0版本增加了保护模式，需要我们设置密码，如果不想设置密码，就关闭保护模式：<code>protected-mode no</code></li>
<li>设置redis以守护线程方式启动：<code>daemonize yes</code></li>
<li>配置pid，log，db文件的保存地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pidfile /opt/redis-3.2.8/pid/redis.pid</div><div class="line">logfile /opt/redis-3.2.8/log/redis.log</div><div class="line">dir /opt/redis-3.2.8/db</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>其他配置就默认即可，有需要再自行修改</p>
<ul>
<li><p>编写redis启动脚本：<code>vi /etc/init.d/redis</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></div><div class="line"><span class="comment"># as it does use of the /proc filesystem.</span></div><div class="line">PATH=/opt/redis-3.2.8/bin:/sbin:/usr/bin:/bin</div><div class="line">REDISPORT=6379</div><div class="line">EXEC=/opt/redis-3.2.8/bin/redis-server</div><div class="line">CLIEXEC=/opt/redis-3.2.8/bin/redis-cli</div><div class="line">PIDFILE=/opt/redis-3.2.8/pid/redis.pid</div><div class="line">CONF=<span class="string">"/opt/redis-3.2.8/redis.conf"</span></div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">    start)</div><div class="line">        <span class="keyword">if</span> [ <span class="_">-f</span> <span class="variable">$PIDFILE</span> ]</div><div class="line">        <span class="keyword">then</span></div><div class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> exists, process is already running or crashed"</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">                <span class="built_in">echo</span> <span class="string">"Starting Redis server..."</span></div><div class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">        ;;</div><div class="line">    stop)</div><div class="line">        <span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="variable">$PIDFILE</span> ]</div><div class="line">        <span class="keyword">then</span></div><div class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> does not exist, process is not running"</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">                PID=$(cat <span class="variable">$PIDFILE</span>)</div><div class="line">                <span class="built_in">echo</span> <span class="string">"Stopping ..."</span></div><div class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT</span> shutdown</div><div class="line">                <span class="keyword">while</span> [ -x /proc/<span class="variable">$&#123;PID&#125;</span> ]</div><div class="line">                <span class="keyword">do</span></div><div class="line">                    <span class="built_in">echo</span> <span class="string">"Waiting for Redis to shutdown ..."</span></div><div class="line">                    sleep 1</div><div class="line">                <span class="keyword">done</span></div><div class="line">                <span class="built_in">echo</span> <span class="string">"Redis stopped"</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">        ;;</div><div class="line">    *)</div><div class="line">        <span class="built_in">echo</span> <span class="string">"Please use start or stop as first argument"</span></div><div class="line">        ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置服务权限：<code>chmod a+x /etc/init.d/redis</code></p>
</li>
</ul>
<h1 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h1><ul>
<li>启动：<code>service redis start</code></li>
<li>关闭：<code>service redis stop</code></li>
<li>查看：<code>ps -ef | grep redis</code>，<code>netstat -anptu | grep 6379</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS6.7使用yum安装有时候没有比较新的版本，所以手动安装，下面记录一下步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-13f399d148cd1ad3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;redis&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;下载最新版本&quot;&gt;&lt;a href=&quot;#下载最新版本&quot; class=&quot;headerlink&quot; title=&quot;下载最新版本&quot;&gt;&lt;/a&gt;下载最新版本&lt;/h1&gt;&lt;p&gt;以3.2.8为例，附上地址：&lt;a href=&quot;https://redis.io/&quot;&gt;redis-3.2.8.tar.gz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="https://peijie-sh.github.io/categories/NoSQL/"/>
    
    
      <category term="Linux" scheme="https://peijie-sh.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://peijie-sh.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Java中的代理</title>
    <link href="https://peijie-sh.github.io/2017/02/17/%E8%B0%88%E8%B0%88Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86/"/>
    <id>https://peijie-sh.github.io/2017/02/17/谈谈Java中的代理/</id>
    <published>2017-02-17T07:36:35.000Z</published>
    <updated>2017-03-04T12:49:08.011Z</updated>
    
    <content type="html"><![CDATA[<p>代理是Java常用的设计模式，代理类通过调用被代理类的相关方法，实现对相关方法增强。比如加入事务、日志、报警发邮件等操作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4059338-83f70e36399f4ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java.png"><br><a id="more"></a></p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理，就是由程序员手动编写代理类或者用工具生成代理类的代码，再进行编译生成class文件，实现代理。比如简单工厂模式。</p>
<p>用法：</p>
<ul>
<li>代理类和目标类都实现相同接口。</li>
<li>代理类持有目标类的引用。</li>
</ul>
<p>缺点：<br>静态代理要为每个目标类创建一个代理类，当需要代理的对象太多，那么代理类也变得很多。代理类违背了可重复代理只写一次的原则。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>为了解决静态代理的缺点，于是引入了动态代理。<br>它有一个好处，那就是不用写很多代理类，生成的代理类数量是固定的。<br>一般动态代理分为2种：</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK动态代理是JDK自带的，不依赖第三方框架。<br>它的实现原理，就是利用Java的反射机制，创建一个实现接口的代理类。</p>
<p>用法：</p>
<ul>
<li>被代理对象必须实现接口。</li>
<li>代理对象由代理工厂自动生成。</li>
</ul>
<p>下面贴个例子</p>
<p>接口类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;   </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;   </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;   </div><div class="line">    System.out.println(<span class="string">"do 了 some thing ..."</span>);   </div><div class="line">  &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理工厂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    <span class="comment">//绑定委托对象，并返回代理类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="comment">//绑定该类实现的所有接口，取得代理类 </span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</div><div class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy , Method method , Object[] args)</span><span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//这里就可以进行所谓的AOP编程了</span></div><div class="line">        <span class="comment">//在调用具体函数方法前，执行功能处理</span></div><div class="line">        result = method.invoke(target, args);</div><div class="line">        <span class="comment">//在调用具体函数方法后，执行功能处理</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">           ProxyHandler proxy = <span class="keyword">new</span> ProxyHandler();</div><div class="line">           <span class="comment">//绑定该类实现的所有接口</span></div><div class="line">           Subject sub = (Subject) proxy.bind(<span class="keyword">new</span> RealSubject());</div><div class="line">           sub.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h2><p>使用CGLIB代理需要引入CGLIB库，它使用字节码技术实现代理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</div><div class="line">      </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;    </div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Object targetObject;<span class="comment">// CGLib需要代理的目标对象    </span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxyObject</span><span class="params">(Object obj)</span> </span>&#123;    </div><div class="line">        <span class="keyword">this</span>.targetObject = obj;    </div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();    </div><div class="line">        enhancer.setSuperclass(obj.getClass());    </div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);    </div><div class="line">        Object proxyObj = enhancer.create();    </div><div class="line">        <span class="keyword">return</span> proxyObj;<span class="comment">// 返回代理对象    </span></div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args,    </span></span></div><div class="line">            MethodProxy methodProxy) <span class="keyword">throws</span> Throwable &#123;    </div><div class="line">        Object obj = <span class="keyword">null</span>;    </div><div class="line">        <span class="keyword">if</span> (<span class="string">"addUser"</span>.equals(method.getName())) &#123;<span class="comment">// 过滤方法    </span></div><div class="line">            checkPopedom();<span class="comment">// 检查权限    </span></div><div class="line">        &#125;    </div><div class="line">        obj = method.invoke(targetObject, args);    </div><div class="line">        <span class="keyword">return</span> obj;    </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPopedom</span><span class="params">()</span> </span>&#123;    </div><div class="line">        System.out.println(<span class="string">"检查权限  checkPopedom()!"</span>);    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    </div><div class="line">		Subject sub = (Subject) <span class="keyword">new</span> CGLibProxy().createProxyObject(<span class="keyword">new</span> RealSubject());</div><div class="line">		sub.doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2种动态代理的区别"><a href="#2种动态代理的区别" class="headerlink" title="2种动态代理的区别"></a>2种动态代理的区别</h2><p>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br>而CGLIB动态代理是利用asm开源包，加载代理对象类的class文件，修改其字节码生成子类来处理。</p>
<p>在 Spring 中，</p>
<ul>
<li>如果目标对象实现了接口，默认情况下会采用JDK动态代理实现AOP </li>
<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP </li>
<li>如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换</li>
</ul>
<p>如何强制使用CGLIB实现AOP？</p>
<ul>
<li>添加CGLIB依赖</li>
<li>在Spring配置文件中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></li>
<li>如果是SpringBoot，在配置文件设置<code>spring.aop.proxy-target-class=true</code></li>
</ul>
<p>JDK动态代理和CGLIB字节码生成的区别？</p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对未实现接口的类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</li>
<li>因为是继承，所以该类或方法最好不要声明成final</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理是Java常用的设计模式，代理类通过调用被代理类的相关方法，实现对相关方法增强。比如加入事务、日志、报警发邮件等操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-83f70e36399f4ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;java.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="动态代理" scheme="https://peijie-sh.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM（一）：JVM内存结构</title>
    <link href="https://peijie-sh.github.io/2017/02/16/%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://peijie-sh.github.io/2017/02/16/理解JVM（一）：JVM内存结构/</id>
    <published>2017-02-16T07:25:12.000Z</published>
    <updated>2018-08-20T12:21:16.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在<code>JVM</code>中，内存主要被分为5类</strong><br><img src="http://upload-images.jianshu.io/upload_images/4059338-8a05e9cb9a61a962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM内存结构.jpg"></p>
<a id="more"></a>
<h2 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆<code>Heap</code></h2><ul>
<li>虚拟机内存管理中最大的一块内存空间。</li>
<li>存放关键字<code>new</code>创建的对象实例和数组。</li>
<li>堆内存被所有线程共享。</li>
<li>这块内存区由<code>JVM</code>（Java虚拟机）自己管理。当使用new创建对象时，不必指定分配空间的大小，<code>JVM</code>会动态自动分配一块区域；在程序执行过程中，没有指向此对象的引用时，此对象就被标记为可被回收状态，将由<code>GC</code>（垃圾回收器）在一个不确定的时间自动回收，释放所占的内存空间。</li>
<li>从内存回收的角度看，垃圾收集器大都基于分代收集算法，所以堆一般分为<code>新生代</code>和<code>老年代</code>，更细致可划分为：<code>Eden空间</code>，<code>From Survivor空间</code>，<code>To Survivor空间</code>。</li>
</ul>
<h2 id="虚拟机栈VM-Stack"><a href="#虚拟机栈VM-Stack" class="headerlink" title="虚拟机栈VM Stack"></a>虚拟机栈<code>VM Stack</code></h2><ul>
<li>存放8种基本类型的数据和对象引用（不是对象）。</li>
<li>每个线程有自己的单独的栈。</li>
<li>先进后出，后进先出。</li>
<li>因为主要存放基本类型数据变量，所以分配空间比堆快。当超出变量的作用域，将由编译器立即释放空间。</li>
</ul>
<h2 id="本地方法栈Native-Method-Stack"><a href="#本地方法栈Native-Method-Stack" class="headerlink" title="本地方法栈Native Method Stack"></a>本地方法栈<code>Native Method Stack</code></h2><ul>
<li>与<code>虚拟机栈</code>类似，<code>虚拟机栈</code>为虚拟机调用Java方法服务，<code>本地方法栈</code>为虚拟机调用Native方法服务。</li>
<li>在HotSpot虚拟机实现中，<code>虚拟机栈</code>和<code>本地方法栈</code>被合并为一个区域。</li>
</ul>
<h2 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器 Program Counter Register"></a>程序计数器 <code>Program Counter Register</code></h2><p>一块较小的内存空间，可看作是当前线程所执行的字节码的 行号指示器。</p>
<p>通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。</p>
<p>特点：</p>
<ul>
<li>线程私有：因为 Java 虚拟机的多线程是通过 线程轮流切换 并 分配处理器执行时间 来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</li>
<li>无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
<h2 id="方法区Method-Area"><a href="#方法区Method-Area" class="headerlink" title="方法区Method Area"></a>方法区<code>Method Area</code></h2><ul>
<li>跟堆一样，被所有的线程共享。</li>
<li>是一个内存逻辑区域，用于存储已被虚<br>拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
</ul>
<h4 id="运行时常量池Runtime-Constant-Pool"><a href="#运行时常量池Runtime-Constant-Pool" class="headerlink" title="运行时常量池Runtime Constant Pool"></a>运行时常量池<code>Runtime Constant Pool</code></h4><ul>
<li>方法区的一部分。</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li>
</ul>
<h1 id="直接内存Direct-Memory"><a href="#直接内存Direct-Memory" class="headerlink" title="直接内存Direct Memory"></a>直接内存<code>Direct Memory</code></h1><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。<br>但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓<br>冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储<br>在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著<br>提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在&lt;code&gt;JVM&lt;/code&gt;中，内存主要被分为5类&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4059338-8a05e9cb9a61a962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JVM内存结构.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://peijie-sh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://peijie-sh.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
